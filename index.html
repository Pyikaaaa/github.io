<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Pyikaaaa</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Pyikaaaa">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pyikaaaa">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Pyikaaaa">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Pyikaaaa" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/PE/" style="font-size: 10px;">PE</a> <a href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" style="font-size: 15px;">Pc样本分析</a> <a href="/tags/RE/" style="font-size: 20px;">RE</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/linuxRE/" style="font-size: 10px;">linuxRE</a> <a href="/tags/windows%E5%86%85%E6%A0%B8/" style="font-size: 10px;">windows内核</a> <a href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95-%E9%80%86%E5%90%91/" style="font-size: 10px;">反调试 逆向</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">喜新念旧   芜湖!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-APC机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/07/APC%E6%9C%BA%E5%88%B6/" class="article-date">
      <time datetime="2021-07-07T05:31:32.000Z" itemprop="datePublished">2021-07-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/07/APC%E6%9C%BA%E5%88%B6/">APC机制</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h1><p>线程如果想结束，一定是<code>自己执行代码把自己杀死</code>，不存在别人把线程结束的情况。如何改变线程的行为，提供一个函数，让他自己去调用，这个函数就是<code>APC</code>，即异步过程调用，把提供的函数挂在APC队列中。</p>
<h2 id="APC本质"><a href="#APC本质" class="headerlink" title="APC本质"></a>APC本质</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><h4 id="线程结构体："><a href="#线程结构体：" class="headerlink" title="线程结构体："></a>线程结构体：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE  &#x2F;&#x2F;子结构体ApcState.即APC队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">nt!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead			&#x2F;&#x2F;2个APC队列（双向链表） 用户APC队列和内核APC队列 ，队列存储的都是APC函数 </span><br><span class="line">   +0x010 Process				&#x2F;&#x2F;线程所属进程或者所挂靠的进程 如果没有挂靠指向的地址与ethread 220成员threadprocess 指向地址相同</span><br><span class="line">   +0x014 KernelApcInProgress	&#x2F;&#x2F;内核APC是否正在执行</span><br><span class="line">   +0x015 KernelApcPending		&#x2F;&#x2F;是否有正在等待执行的内核APC函数 存在置为1</span><br><span class="line">   +0x016 UserApcPending		&#x2F;&#x2F;是否有正在等待执行的用户APC函数  存在置为1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> ApcListHead 两个双向链表组成 16个字节</p>
<p>改变线程执行流程，把给定的函数挂载到链表中，在某个时刻，当前线程会检查当前的函数列表，当里面有函数的时候，就会去调用。</p>
<h4 id="APC结构："><a href="#APC结构：" class="headerlink" title="APC结构："></a>APC结构：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   +0x000 Type             : UChar </span><br><span class="line">   +0x001 SpareByte0       : UChar</span><br><span class="line">   +0x002 Size             : UChar</span><br><span class="line">   +0x003 SpareByte1       : UChar</span><br><span class="line">   +0x004 SpareLong0       : Uint4B</span><br><span class="line">   +0x008 Thread           : Ptr32 _KTHREAD</span><br><span class="line">   +0x00c ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   +0x014 KernelRoutine    : Ptr32     void </span><br><span class="line">   +0x018 RundownRoutine   : Ptr32     void </span><br><span class="line">   +0x01c NormalRoutine    : Ptr32     void    指向我所提供的APC函数（想执行的函数），并不完全等APC函数的地址。</span><br><span class="line">   +0x020 NormalContext    : Ptr32 Void</span><br><span class="line">   +0x024 SystemArgument1  : Ptr32 Void</span><br><span class="line">   +0x028 SystemArgument2  : Ptr32 Void</span><br><span class="line">   +0x02c ApcStateIndex    : Char</span><br><span class="line">   +0x02d ApcMode          : Char</span><br><span class="line">   +0x02e Inserted         : UChar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过NormalRoutine成员找到我所提供的APC函数-指向apc函数）"><a href="#通过NormalRoutine成员找到我所提供的APC函数-指向apc函数）" class="headerlink" title="通过NormalRoutine成员找到我所提供的APC函数   (指向apc函数）"></a>通过NormalRoutine成员找到我所提供的APC函数   (指向apc函数）</h4><p>总结：如果我们想要改变一个线程，可以先提供一个APC，然后通过 <code>_KAPC.NormalRoutine</code> 指向我们提供的APC在哪里，再将APC存到 <code>_KTHREAD.ApcState.ApcListHead</code> 的第一个成员中</p>
<h4 id="当前的线程什么时候会执行所提供的APC函数"><a href="#当前的线程什么时候会执行所提供的APC函数" class="headerlink" title="当前的线程什么时候会执行所提供的APC函数"></a>当前的线程什么时候会执行所提供的APC函数</h4><p>发生系统调用 异常或中断返回用户空间的时候</p>
<p>执行函数KiServiceExit（检查是否有apc请求，有则KiDeliverApc处理—&gt;改变线程流程）</p>
<h3 id="APC相关函数"><a href="#APC相关函数" class="headerlink" title="APC相关函数"></a>APC相关函数</h3><h4 id="KiServiceExit"><a href="#KiServiceExit" class="headerlink" title="KiServiceExit"></a>KiServiceExit</h4><p>这个函数是系统调用 异常或中断返回用户空间的必经之路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KiServiceExit()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cmp [ kthread.apcstate.userapcpending] 0 ;检查是否有用户apc请求。。。。。不判断有无内核apc请求，有内核apc请求先处理内核的（KiDeliveApc处理），处理完了处理用户的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20191219104508974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="KiDeliveApc"><a href="#KiDeliveApc" class="headerlink" title="KiDeliveApc"></a>KiDeliveApc</h4><p>负责执行，处理 APC函数</p>
<h2 id="备用APC队列"><a href="#备用APC队列" class="headerlink" title="备用APC队列"></a>备用APC队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE</span><br><span class="line">+0x170 SavedApcState    : _KAPC_STATE 备用APC队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_KAPC_STATE     _KAPC_STATE     这两个成员的结构是完全一样的</p>
<h3 id="ApcState的含义"><a href="#ApcState的含义" class="headerlink" title="ApcState的含义"></a>ApcState的含义</h3><p>线程队列中的APC函数都是与进程相关联的，具体点说：A进程的T线程中所有的APC函数，要访问的内存地址都是A进程的。</p>
<p>但线程是可以挂靠到其他的进程：比如A进程的线程T，通过修改CR3（   CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。）改为B进程的页目录基址，就可以访问B进程的地址空间，即所谓的进程挂靠。</p>
<p>当T线程挂靠B进程后，APC队列中存储的仍然是原来的APC。具体点说，比如某个<code>APC函数</code>要读取地址为0x12345678的数据，如果此时进行读取<strong>，读到的将是B进程的地址空间，</strong>这样逻辑就错误了。</p>
<p>为了避免混乱，在T线程挂靠B进程时，会将ApcState中的值（apc队列）暂时存储到SavedApcState中，等回到原进程A时，再将APC队列恢复</p>
<p>所以，SavedApcState又称为备用APC队列</p>
<h3 id="挂靠环境下ApcState的意义"><a href="#挂靠环境下ApcState的意义" class="headerlink" title="挂靠环境下ApcState的意义"></a>挂靠环境下ApcState的意义</h3><p>在挂靠的环境下，也是可以先线程APC队列插入APC的  此时插入进ApcState队列。</p>
<p>A进程的T线程挂靠B进程  A是T的所属进程  B是T的挂靠进程<br>ApcState        B进程相关的APC函数<br>SavedApcState    A进程相关的APC函数</p>
<h3 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h3><p>创建一个傀儡进程。 DirectoryTableBase里面存的就页目录表基址。想读哪个进程，就把傀儡进程的DirectoryTableBase改成哪个进程的的。再用标准api读傀儡进程内存，很安全的，杀软还不报</p>
<h3 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE</span><br><span class="line">+0x0b8 ApcQueueable     : Pos 5, 1 Bit &#x2F;&#x2F;用于表示是否可以向线程的APC队列中插入APC</span><br><span class="line">+0x134 ApcStateIndex    : UChar &#x2F;&#x2F;0 正常状态 1 挂靠状态 2当前环境 3 插入apc时的当前环境</span><br><span class="line">+0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE  ！！&#x2F;&#x2F;两种情况下指向apc队列（apcstate savedapcstate）</span><br><span class="line">+0x170 SavedApcState    : _KAPC_STATE 备用APC队列 与acpstate一样的结构</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了操作方便（找到apc队列方便），KTHREAD结构体中定义了一个指针数组ApcStatePointer，长度为2</p>
<p>正常情况下：</p>
<blockquote>
<p> ApcStatePointer[0]指向ApcState</p>
<p> ApcStatePointer[1]指向SavedApcState</p>
</blockquote>
<p>挂靠情况下：</p>
<blockquote>
<p> ApcStatePointer[0]指向SavedApcState</p>
<p> ApcStatePointer[1]指向ApcState</p>
</blockquote>
<h3 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h3><p>ApcStateIndex用来标识当前线程处于什么状态：0正常状态 1挂靠状态</p>
<h3 id="ApcStatePointer与ApcStateIndex组合寻址-（寻址方便）"><a href="#ApcStatePointer与ApcStateIndex组合寻址-（寻址方便）" class="headerlink" title="ApcStatePointer与ApcStateIndex组合寻址 （寻址方便）"></a>ApcStatePointer与ApcStateIndex组合寻址 （寻址方便）</h3><p>正常情况下，向ApcState队列插入APC时：</p>
<blockquote>
<p> ApcStatePointer[0]指向ApcState，此时ApcStateIndex的值为0</p>
<p> ApcStatePointer[ApcStateIndex]指向ApcState</p>
</blockquote>
<p>挂靠情况下，向ApcState队列中插入APC时：</p>
<blockquote>
<p> ApcStatePointer[1]指向ApcState，此时ApcStateIndex的值为1</p>
<p> ApcStatePointer[ApcStateIndex]指向ApcState</p>
</blockquote>
<p><strong>无论什么环境下，ApcStatePointer[ApcStateIndex]指向的都是ApcState，ApcState则总是表示线程当前使用的APC状态</strong></p>
<h3 id="ApcQueueable"><a href="#ApcQueueable" class="headerlink" title="ApcQueueable"></a>ApcQueueable</h3><p>用于表示是否可以向线程的APC队列中插入APC。</p>
<p>当线程正在执行退出的代码时，会将这个值设置为0，如果此时执行插入APC的代码，在插入函数中会判断这个值的状态，如果为0，则插入失败。</p>
<h2 id="APC挂入过程"><a href="#APC挂入过程" class="headerlink" title="APC挂入过程"></a>APC挂入过程</h2><h3 id="KAPC结构"><a href="#KAPC结构" class="headerlink" title="KAPC结构"></a>KAPC结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +0x000 Type		&#x2F;&#x2F;类型  APC类型为0x12</span><br><span class="line">   +0x002 Size		&#x2F;&#x2F;本结构体的大小  0x30</span><br><span class="line">   +0x004 Spare0    	&#x2F;&#x2F;未发现被使用                             </span><br><span class="line">   +0x008 Thread 		&#x2F;&#x2F;属于哪个线程                                  </span><br><span class="line">   +0x00c ApcListEntry	&#x2F;&#x2F;APC队列挂的位置 双向链表 ，KiInsertQueueApc函数将 将KAPC挂到对应的队列中（挂到KAPC的成员ApcListEntry指向处）</span><br><span class="line">   +0x014 KernelRoutine	&#x2F;&#x2F;指向一个函数(调用ExFreePoolWithTag 释放APC)</span><br><span class="line">   +0x018 RundownRoutine&#x2F;&#x2F;略 </span><br><span class="line">   +0x01c NormalRoutine	&#x2F;&#x2F;用户APC ：用户APC 总入口  或者 内核apc ：真正的内核apc函数 ！！</span><br><span class="line">   +0x020 NormalContext	&#x2F;&#x2F;内核APC：NULL  用户APC：真正的APC函数 ！！</span><br><span class="line">   +0x024 SystemArgument1&#x2F;&#x2F;APC函数的参数	</span><br><span class="line">   +0x028 SystemArgument2&#x2F;&#x2F;APC函数的参数</span><br><span class="line">   +0x02c ApcStateIndex	&#x2F;&#x2F;APC函数挂哪个队列，有四个值：0 1 2 3</span><br><span class="line">   +0x02d ApcMode	&#x2F;&#x2F;当前的APC是用户APC还是内核APC</span><br><span class="line">   +0x02e Inserted	&#x2F;&#x2F;当前的KAPC结构体是否已经插入到APC队列 挂入前：0  挂入后  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Type ：类型。在Windows里，任何一种内核对象都有一个编号，这个编号用来标识你是属于哪一种类型，APC本身也是一种内核对象，它也有一个编号，是0x12</li>
<li>Thread：每一个线程都有自己的APC队列，这个成员指定了APC属于哪一个线程</li>
<li>ApcListEntry：APC队列挂的位置，是一个双向链表，通过这个双向链表可以找到下一个APC</li>
<li>NormalRoutine：如果当前是内核APC，通过这个值找到的就是真正的内核APC函数；如果当前的APC是用户APC，那么这个位置指向的是用户APC总入口，通过这个总入口可以找到所有用户提供的APC函数<br>NormalContext：如果当前是内核APC，通过这个值为空；如果当前的APC是用户APC，那么这个值指向的是真正的用户APC函数</li>
</ul>
<h3 id="挂入过程"><a href="#挂入过程" class="headerlink" title="挂入过程"></a>挂入过程</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-G9mKCBcJ-1625635962417)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210706195310593.png)]</p>
<h3 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VOID KeInitializeApc</span><br><span class="line">(</span><br><span class="line">	IN PKAPC Apc,&#x2F;&#x2F;KAPC指针</span><br><span class="line">	IN PKTHREAD Thread,&#x2F;&#x2F;目标线程</span><br><span class="line">	IN KAPC_ENVIRONMENT TargetEnvironment,&#x2F;&#x2F;0 1 2 3四种状态</span><br><span class="line">	IN PKKERNEL_ROUTINE KernelRoutine,&#x2F;&#x2F;销毁KAPC的函数地址</span><br><span class="line">	IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span><br><span class="line">	IN PKNORMAL_ROUTINE NormalRoutine,&#x2F;&#x2F;用户APC总入口或者内核apc函数</span><br><span class="line">	IN KPROCESSOR_MODE Mode,&#x2F;&#x2F;要插入用户apc队列还是内核apc队列</span><br><span class="line">	IN PVOID Context&#x2F;&#x2F;内核APC：NULL  用户APC：真正的APC函数</span><br><span class="line">) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-P17R77Ph-1625635962418)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210706201058231.png)]</p>
<h3 id="ApcStateIndex-1"><a href="#ApcStateIndex-1" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h3><p>与KTHREAD(+0x134)的属性同名，但含义不一样：</p>
<p>ApcStateIndex有四个值：</p>
<p>0 原始环境-&gt;插入到当前线程的所属进程APC队列，不管是否挂靠都插入到当前线程的所属进程。<br>1 挂靠环境<br>2 当前环境-&gt;插入到<code>当前进程</code>的APC队列，如果没有挂靠，当前进程则是父进程，如果挂靠了，当前进程就是挂靠进程</p>
<p>初始化时的值</p>
<p>3 <code>插入APC时的</code>当前环境-&gt;<code>线程随时处于切换状态</code> 当值为3时，在插入APC之前会判断当前线程是否处于挂靠状态 再进行APC插入<br>插入时的值</p>
<h3 id="KiInsertQueueApc"><a href="#KiInsertQueueApc" class="headerlink" title="KiInsertQueueApc"></a>KiInsertQueueApc</h3><ol>
<li>根据KAPC结构中的ApcStateIndex找到对应的APC队列</li>
<li>再根据KAPC结构中的ApcMode确定是用户队列还是内核队列</li>
<li>将KAPC挂到对应的队列中，挂到KAPC的==ApcListEntry==处 ？？？？？？  </li>
<li>再根据KAPC结构中的Inserted置1，标识当前的KAPC为已插入状态</li>
<li>修改KAPC_STATE结构中的KernelApcPending/UserApcPending</li>
</ol>
<h2 id="内核APC的执行过程"><a href="#内核APC的执行过程" class="headerlink" title="内核APC的执行过程"></a>内核APC的执行过程</h2><p>异步过程调用</p>
<p>内核APC执行流程总结：</p>
<p>判断第一个链表(内核APC队列)是否为空<br>判断KTHREAD.ApcState.KernelApcInProgress(是否正在执行内核APC)是否为1<br>判断是否禁用内核APC(KTHREAD.KernelApcDisable是否为1)<br>将当前KAPC结构体从链表中摘除<br>执行KAPC.KernelRoutine指定的函数 释放KAPC结构体占用的空间<br>将KTHREAD.ApcState.KernelApcInProgress设置为1 标识正在执行内核APC<br>执行真正的内核APC函数(KAPC.NormalRoutine)<br>执行完毕 将KernelApcInProgress改为0</p>
<p>用户APC的执行过程<br>当产生系统调用 中断或者异常，线程在返回用户空间前都会调用_KiServiceExit函数，在_KiServiceExit函数里会判断是否有要执行的用户APC，如果有则调用KiDeliverApc函数进行处理</p>
<p>执行用户APC时的堆栈操作<br>处理用户APC要比处理内核APC复杂的多，因为用户APC函数要在用户空间执行，这里涉及到大量的换栈操作：</p>
<p>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器 栈的位置等等，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可</p>
<p>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到真正执行APC的位置</p>
<p>每处理一个用户APC就会涉及到：内核—&gt;用户空间—&gt;再回到内核空间</p>
<p>执行用户APC最为关键的就是理解堆栈操作的细节</p>
<p>用户APC执行流程总结：</p>
<p>判断用户APC链表是否为空<br>判断第一个参数是为1，为1说明处理用户APC和内核APC<br>判断ApcState.UserApcPending(是否正在执行用户APC)是否为1<br>将ApcState.UserApcPending设置为0，表示正在处理用户APC<br>链表操作 将当前APC从用户队列中拆除<br>调用函数(KAPC.KernelRoutine)释放KAPC结构体内存空间<br>调用KiInitializeUserApc函数</p>
<p>KiInitializeUserApc函数分析：备份CONTEXT<br>线程进0环时，原来的运行环境(寄存器栈顶等)保存到_Trap_Frame结构体中，如果要提前返回3环去处理用户APC，就必须修改_Trap_Frame结构体,因为此时Trap_Frame中存储的EIP是从三环进零环时保存的EIP，而不是用户APC函数的地址</p>
<p>比如：进0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置，还有堆栈ESP也要修改为处理APC需要的堆栈。那原来的值怎么办？处理完APC后该如何返回原来的位置呢？</p>
<p>KiInitializeUserApc要做的第一件事就是备份：</p>
<p>将原来_Trap_Frame的值备份到一个新的结构体中(CONTEXT)，这个功能由其子函数KeContextFromKframes来完成</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-boWvAAVS-1625635962420)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210707133006329.png)]</p>
<p><strong>总结：</strong></p>
<ol>
<li>段寄存器 SS DS FS GS</li>
<li>修改EFLAGS寄存器</li>
<li>修改ESP</li>
<li>修改EIP-&gt;ntdll.KiUserApcDispatcher</li>
</ol>
<h3 id="ntdll-KiUserApcDispatcher函数分析"><a href="#ntdll-KiUserApcDispatcher函数分析" class="headerlink" title="ntdll.KiUserApcDispatcher函数分析"></a>ntdll.KiUserApcDispatcher函数分析</h3><ol>
<li>返回内核，如果还有用户APC，重复上面的执行过程<br>后该如何返回原来的位置呢？</li>
</ol>
<p>KiInitializeUserApc要做的第一件事就是备份：</p>
<p>将原来_Trap_Frame的值备份到一个新的结构体中(CONTEXT)，这个功能由其子函数KeContextFromKframes来完成</p>
<p>[外链图片转存中…(img-boWvAAVS-1625635962420)]</p>
<p><strong>总结：</strong></p>
<ol>
<li>段寄存器 SS DS FS GS</li>
<li>修改EFLAGS寄存器</li>
<li>修改ESP</li>
<li>修改EIP-&gt;ntdll.KiUserApcDispatcher</li>
</ol>
<h3 id="ntdll-KiUserApcDispatcher函数分析-1"><a href="#ntdll-KiUserApcDispatcher函数分析-1" class="headerlink" title="ntdll.KiUserApcDispatcher函数分析"></a>ntdll.KiUserApcDispatcher函数分析</h3><ol>
<li>返回内核，如果还有用户APC，重复上面的执行过程</li>
<li>如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体，回到0环</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows%E5%86%85%E6%A0%B8/" rel="tag">windows内核</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Trojan-Dropper.Win32.Convagent.gen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/Trojan-Dropper.Win32.Convagent.gen/" class="article-date">
      <time datetime="2021-07-05T14:03:45.440Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Trojan-Dropper-Win32-Convagent-gen"><a href="#Trojan-Dropper-Win32-Convagent-gen" class="headerlink" title="Trojan-Dropper.Win32.Convagent.gen"></a>Trojan-Dropper.Win32.Convagent.gen</h1><p>Trojan-Dropper.Win32.Convagent.gen家族：先再缓冲区读取释放⽂件的数据，将数据进行解密，解密函数40B5b0，最后创建⽂件，写⼊⽂件。</p>
<hr>
<h2 id="51f4e1aca8ece1a28c375ef06c94a60d分析"><a href="#51f4e1aca8ece1a28c375ef06c94a60d分析" class="headerlink" title="51f4e1aca8ece1a28c375ef06c94a60d分析"></a>51f4e1aca8ece1a28c375ef06c94a60d分析</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p><img src="https://i.imgur.com/xkT8m6H.png"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="patch-Guard" class="article article-type-patch" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/Guard/" class="article-date">
      <time datetime="2021-07-05T09:02:12.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/Guard/">Guard</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-脱壳" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/%E8%84%B1%E5%A3%B3/" class="article-date">
      <time datetime="2021-07-05T06:37:06.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/%E8%84%B1%E5%A3%B3/">脱壳</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h4><p>1.壳：</p>
<p>一：加壳的目的：为了隐藏程序真正的OEP（入口点），防止被破解。</p>
<p>二：加壳软件是一种在编译好可执行文件之后，为了一些特定的需求，而做的一些事情，常见需求有：</p>
<p>​        有一些版权信息需要保护起来，不想让别人随便改动</p>
<p>​        为了让程序小一点，从而方便使用（把可执行文件进行压缩使用）</p>
<p>​        给木马等软件加壳以避免杀毒软件</p>
<p>三：壳的加载过程：</p>
<p>​    一般壳的装载过程：</p>
<p>​            （1）获取壳所需要使用的API地址<br>加壳后的文件，比未加壳的文件的输入表所引入的API少（甚至只有Kernel32.dll以及GetProcAddress这个API函数）；壳实际上还需要其他API函数来完成一些事情，它为了隐藏这些API，一般只在壳的代码中用显式链接的方式来动态加载这些API</p>
<p>​            （2）解密原程序的各个区块（Section）的数据<br>壳一般是按区块加密的，那么解密的时候也是按区块解密，并且把解密的区块数据按照区块的定义放在合适的内存位置；如果加壳时用到了压缩技术，那么在解密之前，需要用对应的解压缩技术。</p>
<p>​            （3）重定位</p>
<p>​            （4）HOOK-API<br>程序文件中的输入表的作用：让Windows系统在程序运行时提供API的实际地址给程序使用，这个是在程序的第一行代码执行之前，由Windows系统完成的操作。<br>而壳一般是修改了原程序文件的输入表，然后仿照Windows系统的工作来填充输入表中的相关数据，在填充过程中，外壳就可填充HOOK-API的代码地址，从而可以间接获得程序的控制权。</p>
<p>​            （5）跳转到程序原入口点<br>这个时候，壳把控制权交还给原程序</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LrESqGdT-1625549563239)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210204180643199.png)]</p>
<p>2.什么是脱壳</p>
<p>找到程序真正的入口点（OEP）</p>
<h4 id="3-分类："><a href="#3-分类：" class="headerlink" title="3.分类："></a>3.分类：</h4><p>简单分为两类  压缩壳  加密壳</p>
<p>压缩壳只是减少程序体积对资源进行压缩，加密壳是程序输入表等等进行加密保护</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fjfs4YOc-1625549563243)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210204172527304.png)]</p>
<h4 id="4-脱壳工具"><a href="#4-脱壳工具" class="headerlink" title="4.脱壳工具"></a>4.脱壳工具</h4><p>OD   找OEP 利用插件dump也可脱壳</p>
<p> PEID/Exeinfope..   查壳</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e8937b957f4a76897a9845ae697f9ad.png"></p>
<p>ImportREC  修复的</p>
<p>LordPE  脱壳的   win10 用不了  </p>
<p>无法找到进程</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ce84b24c452bc70903f70a5af679d672.png"></p>
<p>方法：右击相应的进程, 修复镜像大小, 完整转存.</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e6cdab46ee5f0ade906607cf344c58f.png"></p>
<p>脱壳机也行</p>
<h4 id="5-预备知识："><a href="#5-预备知识：" class="headerlink" title="5.预备知识："></a>5.预备知识：</h4><p>1.PUSHAD （压栈） 代表程序的入口点,</p>
<p>●把从EAX到EDI寄存器压入堆栈，保存现场（原来的值）</p>
<p>2.POPAD （出栈） 代表程序的出口点，与PUSHAD想对应，一般找到这个OEP就在附近<br>3.OEP：程序的入口点，软件加壳就是隐藏了OEP（或者用了假的OEP/FOEP），只要我们找到程序真正的OEP，就可以立刻脱壳。</p>
<h4 id="6-步骤"><a href="#6-步骤" class="headerlink" title="6.步骤"></a>6.步骤</h4><h5 id="1-识别壳"><a href="#1-识别壳" class="headerlink" title="1.识别壳"></a>1.识别壳</h5><p>1.查壳工具</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ae2a7ab8e70eb9a30b7d0b2250e003d5.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6c99e4676ca8999a2ff38c7a21779e4.png"></p>
<p>目的：知道壳的版本和编译程序的语言和编译器</p>
<p>2.通过入口特征和区段特征来识别</p>
<p>连接器版本</p>
<p>区段</p>
<p>壳的版本</p>
<p>结合OD看入口点特征 ，需要积累 多看</p>
<p>常见入口点特征：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w_g3366/article/details/94595881">https://blog.csdn.net/w_g3366/article/details/94595881</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7f0584d2060a14bb49cdeffddd2e192a.png"></p>
<p>判断是什么语言写的 可以查看区段和入口特征:</p>
<p>(1)VC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。</p>
<p>(2)VS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。</p>
<p>(3)易语言独立编译是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同</p>
<p>(4)非独立编译比较容易识别，入口特征和模块特征都有krnln.fnr</p>
<p><strong>入口特征</strong>可以通过<a target="_blank" rel="noopener" href="http://www.52pojie.cn/thread-14986-1-1.html">OllyDBG</a>载入获得，载入后可以按一下“Ctrl+A”，让OD分析一下代码，就可以把入口点一些特征字符串分析出来，对于Shielden、Safengine、VProtect这类加壳程序都可以使用这种方法判断出来。</p>
<h5 id="2-寻找oep"><a href="#2-寻找oep" class="headerlink" title="2.寻找oep"></a>2.寻找oep</h5><h5 id="3-dump"><a href="#3-dump" class="headerlink" title="3.dump"></a>3.dump</h5><h5 id="4-修复文件"><a href="#4-修复文件" class="headerlink" title="4.修复文件"></a>4.修复文件</h5><h5 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h5><p>importREC自动修复失败 手动修复IAT</p>
<h4 id="7-方法相关知识："><a href="#7-方法相关知识：" class="headerlink" title="7.方法相关知识："></a>7.方法相关知识：</h4><h5 id="（1）ESP定律法："><a href="#（1）ESP定律法：" class="headerlink" title="（1）ESP定律法："></a>（1）ESP定律法：</h5><p><strong>堆栈平衡</strong></p>
<p>壳代码就像一个函数，进入时会开辟堆栈，保存寄存器环境，退出时会恢复堆栈，恢复寄存器。所以是堆栈平衡</p>
<p>所以 在壳代码操作了堆栈后对堆栈设置硬件访问断点，然后运行程序，当断点命中的时候，就是退出壳代码的时候</p>
<p>在其附近单步几次。就可以到达程序原始的OEP</p>
<p>❤ 第一次回到初始空栈状态就可以找到我们的OEP</p>
<p>●断点：运行到这个地方就zanting</p>
<p>●访问断点再次访问这个地方 就停</p>
<p><strong>！！注意！！</strong></p>
<p>普通软件断点用于代码段，硬件断点可以用于内存，堆栈上</p>
<h5 id="（2）内存镜像法："><a href="#（2）内存镜像法：" class="headerlink" title="（2）内存镜像法："></a>（2）内存镜像法：</h5><p>内存镜像法下的内存访问断点</p>
<p>内存断点一般分为 内存访问断点  内存写入断点</p>
<p>内存访问断点：当代码读取内存的数据的时候程序暂停</p>
<p>内存写入断点：当代码向内存中写入数据的时候程序暂停</p>
<p>❤总结：</p>
<p>第一次内存访问断点：为了让前面的部分先解码</p>
<p>第二次内存访问断点：为了让后面部分也解码完成，同时在访问代码段的时候，很可能会直接断在OEP处</p>
<h4 id="8-脱壳方法："><a href="#8-脱壳方法：" class="headerlink" title="8.脱壳方法："></a>8.脱壳方法：</h4><h5 id="方法一：单步跟踪法"><a href="#方法一：单步跟踪法" class="headerlink" title="方法一：单步跟踪法"></a>方法一：单步跟踪法</h5><p>1.用OD载入，点“不分析代码！”<br>2.单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现！（通过F4）<br>3.遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点——&gt;运行到所选）<br>4.绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现！</p>
<p>●如果让程序向上跳转，则可能程序往反方向跳转，无休无止，也就找不到OEP）</p>
<p>5.如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑飞，这样很快就能到程序的OEP<br>6.在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入<br>7.一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN的一般很快就会到程序的OEP。<br> PS:在有些壳无法向下跟踪的时候，我们可以在附近找到没有实现的大跳转，右键–&gt;“跟随”,然后F2下断，Shift+F9运行停在“跟随”的位置，再取消断点，继续F8单步跟踪。一般情况下可以轻松到达OEP！</p>
<p>❤ OD 不能在nop处下断点</p>
<h5 id="方法二：ESP定律法"><a href="#方法二：ESP定律法" class="headerlink" title="方法二：ESP定律法"></a>方法二：ESP定律法</h5><p> ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）<br>1.开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）。<br>（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）<br>2.在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车！<br>3.选中下断的地址，断点—&gt;硬件访问断点&gt;WORD断点。<br>4.按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP。</p>
<h5 id="方法三：内存镜像法"><a href="#方法三：内存镜像法" class="headerlink" title="方法三：内存镜像法"></a>方法三：内存镜像法</h5><p>1：用OD打开软件！<br>2：点击选项——调试选项——异常，把里面的忽略全部√上！CTRL+F2重载下程序！<br>3：按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的.CODE（也就是00401000处），按F2下断点！然后按SHIFT+F9（或者是在没异常情况下按F9），直接到达程序OEP！</p>
<h5 id="方法四：一步到达OEP"><a href="#方法四：一步到达OEP" class="headerlink" title="方法四：一步到达OEP"></a>方法四：一步到达OEP</h5><p>1.开始按Ctrl+F,输入：popad（只适合少数壳，包括UPX，ASPACK壳），然后按下F2，F9运行到此处<br>2.来到大跳转处，点下F8，到达OEP！</p>
<h5 id="方法五：最后一次异常法"><a href="#方法五：最后一次异常法" class="headerlink" title="方法五：最后一次异常法"></a>方法五：最后一次异常法</h5><p>1：用OD打开软件<br>2：点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序<br>3：一开始程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按SHIFT+F9到程序运行的次数m！<br>4：CTRL+F2重载程序，按SHIFT+F9（这次按的次数为程序运行的次数m-1次）<br>5：在OD的右下角我们看见有一个”SE 句柄”，这时我们按CTRL+G，输入SE 句柄前的地址！<br>6：按F2下断点！然后按SHIFT+F9来到断点处！<br>7：去掉断点，按F8慢慢向下走！<br>8：到达程序的OEP！</p>
<p>❤ 这是总结出来的一种捷径. </p>
<p> 原理就是. 最后一次异常之后就正常运行了. 这个正常运行必须是真正的OEP. 所以最后一次异常是最靠近的</p>
<h5 id="方法六：模拟跟踪法"><a href="#方法六：模拟跟踪法" class="headerlink" title="方法六：模拟跟踪法"></a>方法六：模拟跟踪法</h5><p>1：先试运行，跟踪一下程序，看有没有SEH暗桩之类<br>2：ALT+M打开内存镜像，找到（包含=SFX,imports,relocations）<br>内存镜像，项目 30<br>地址=0054B000<br>大小=00002000 (8192.)<br>Owner=check 00400000<br>区段=.aspack<br>包含=SFX,imports,relocations<br>类型=Imag 01001002<br>访问=R<br>初始访问=RWE<br>3：地址为0054B000，如是我们在命令行输入tc eip&lt;0054B000,回车，正在跟踪ing。。<br>PS:大家在使用这个方法的时候，要理解他是要在怎么样的情况下才可以使用</p>
<h5 id="方法七：“SFX”法"><a href="#方法七：“SFX”法" class="headerlink" title="方法七：“SFX”法"></a>方法七：“SFX”法</h5><p>1：设置OD，忽略所有异常，也就是说异常选项卡里面都打上勾<br>2：切换到SFX选项卡，<strong>选择“字节模式跟踪实际入口（速度非常慢）</strong>”，确定。<br>3：重载程序（如果跳出是否“压缩代码？”选择“否”，OD直接到达OEP）<br>ps:这种方法不要滥用得好，锻炼能力为妙。</p>
<p> 这里最常用的ESP定律法(堆栈平衡原理)，为什么说是ESP呢，当所有的寄存器都压入栈时(pushad)，esp地址的是指向栈顶的地址的，当壳将执行权交给源程序时，esp地址要回到pushad之前的状态，这时就可以看到esp变化了，这就是源程序的入口点。（汇编，汇编，汇编！）</p>
<p>SFX:od程序自带的调试功能，用来寻找相应的OEP</p>
<p>使用注意：SFX使用的范围是当程序载入OD之后，入口点必须是代码段之外才可以使用</p>
<p>总结：</p>
<h4 id="9-例子"><a href="#9-例子" class="headerlink" title="9.例子"></a>9.例子</h4><p>upx壳</p>
<blockquote>
<p>upx的工作原理其实是这样的：首先将程序压缩。<br>所谓的压缩包括两方面：<br>一方面在程序的开头或者其他合适的地方 插入一段代码。<br>另一方面是将程序的其他地方做压缩（也就是上面讲到的压缩）。压缩也可以叫做加密，因为压缩后的程序比较难看懂，原来的代码有很大的不同。</p>
<p>当程序执行时：实时的对程序解压缩。解压缩功能是在第一步时插入的代码完成的功能。</p>
<p>联起来就是：upx可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率。</p>
</blockquote>
<p>用upx压缩之后形式为：1–&gt;2–&gt;3–&gt;4–&gt;5–&gt;6 </p>
<p>最初代码的形式就应该是：7–&gt;8–&gt;9–&gt;5–&gt;6</p>
<p>执行时的形式变为：1–&gt;7–&gt;8–&gt;9–&gt;5–&gt;6  </p>
<p>● 1是upx插入的代码</p>
<p>●内存镜像法： </p>
<p>○需要读取2 3 4内存空间的代码，这个就会存在内存访问，然后把2 3 4 解压出来，就会有内存写入</p>
<p>○把2 看作代码段  3 看做数据段 4 看做资源段 </p>
<p>○假设解码的顺序是按照2 3 4进行</p>
<p>，<strong>第一个内存访问断点</strong>，下在4 资源段处</p>
<p>当程序断下来的时候，说明代码段2和数据段3都解码完成了</p>
<p>1 7 8 4 5 6</p>
<p>○<strong>第二个内存访问断点</strong> ，下在解压完成的代码段</p>
<p>为啥：第二次断下来的时候，4肯定解码完成了，这时候就完成了所有解码，</p>
<p>1 7 8 9 5 6</p>
<p>接下来就是找OEP了，OEP在代码段7中的代码中，所以我们下的是代码段的访问断点，达到OEP就会访问代码段，所以就可以找到OEP进而完成脱壳</p>
<blockquote>
<p>手脱upx方法：</p>
<p>1.单步跟踪</p>
<p>2.一步到达（利用popad）</p>
<p>3.esp定律</p>
<p>4.内存镜像法</p>
</blockquote>
<h4 id="10-dump"><a href="#10-dump" class="headerlink" title="10.dump"></a>10.dump</h4><p>利用od自带的插件ollydump完成脱壳</p>
<h4 id="11-修复文件"><a href="#11-修复文件" class="headerlink" title="11.修复文件"></a>11.修复文件</h4><p>用importREC修复导入表</p>
<p>前提（已经找到OEP）</p>
<p>1、脱壳在当前进程,如脱壳出来的程序不能运行，提示无法定位程序输入点，需要使用<br>importREC修复导入表。<br>2、打开importREC，选正ollydbg正在调试的进程，填入正确的OEP,点ITA AutoSearch，<br>如oep正确将得到正确提示，点GetImport，得到正确的导入表。点Fix Dump，选择脱壳<br>出来的保存文件，Done!（修正后的程序为原程序名后加一下划线，原程序不会被修改。） </p>
<h4 id="12-emmm"><a href="#12-emmm" class="headerlink" title="12.emmm"></a>12.emmm</h4><p>如果直接Dump文件，修复导入表会发现程序仍然不能正常运行，那么他就不是一个单纯的压缩壳，壳中加密技术一般有IAT加密，混淆花指令，偷取OEP,反调试，代码虚拟化</p>
<p>importREC自动修复失败 手动修复IAT：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/5315hejialei/p/7060315.html">https://www.cnblogs.com/5315hejialei/p/7060315.html</a></p>
<p>原理：</p>
<p>程序的IAT是连续的排列的，所以我们只需要找到IAT的起始位置和末位置，就可以确定IAT的地址和大小。在压缩壳中，我们只要找一个调用系统的API的Call的地址，然后在数据窗口中查找，确定IAT起始和结束地址。然后在OD中手动修复</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://img-blog.csdnimg.cn/2020112721264018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MTEzOQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>手脱各种壳：</p>
<p>手脱 <strong>UPX 壳</strong>的捷径</p>
<p>1、直接ESP定律</p>
<p>2、用我们已开始提到的”关键提示“。</p>
<p> 具体操作：OD载入程序后，直接Ctrl+F，输入 POPAD ;</p>
<p>点确定后 来到这个命令所在的位置。按F2，在这个地方下断；</p>
<p>再按F9（运行）；</p>
<p>停止后，按F2取消刚才下的断点。再F8单步！</p>
<p>手脱 <strong>ASPCK</strong> 的壳</p>
<p>脱这个壳用ESP定律，还是相对快捷的。</p>
<p>可以用载入程序后，第二行（是一个CALL）那里面的ESP。 //多数程序这个壳的第二行都是一个CALL 在左OD左下角的命令行中，输入命令：hr ESP地址（如 hr 0012FFA4）；</p>
<p>F9 运行。</p>
<p>然后从OD”调试菜单“中的”硬件断点“<strong>这一项将刚才下的断点删除</strong>，这点很重要！最后F8单步！</p>
<p>用内存镜像法手脱FSG 1.33 和 PCshrink 的壳</p>
<p>1、忽略所有异常 </p>
<p>2、Alt+M 打开内存镜像，找到第一个 ”.rsrc“ </p>
<p>3、F2（下断），F9（运行） </p>
<p>4、Alt+M 打开内存镜像，找到”Code“段；</p>
<p> 5、F2（下断），Shift+F9【这点一定要记住，切记是 Shift+F9】运行；</p>
<p> 6、先按F8，再按下F4，直接到达OEP</p>
<p>PEpack 1.0 和 WinUpack 0.37-0.39 和 RLPack v.1.14-16</p>
<p>用esp定律</p>
<p>手脱 JDpack 壳</p>
<p>脱这个壳推荐使用内存镜像法 。</p>
<p>手脱 PEDiminisher ；Dxpack 0.86 ；</p>
<p>32lite 0.03a ；PEtite 2.2 这几种壳的简单方法</p>
<p>脱PEDiminisher ；Dxpack 0.86 ；</p>
<p>这两种壳的时候，直接用之前讲到的ESP定律，即可完美脱壳。命令：【hr ESP地址】</p>
<p><strong>用ESP脱 32lite 0.03a 后 要注意的是，需要用 ImportREC 这个工具进行修复。</strong>如：00410D50 在输入框中输入 10D50 就可以了【004舍去】</p>
<p><strong>在用ESP定律脱 PEtite 2.2 的时候，推荐选择 Pushad 下面那行地址中的 ESP</strong></p>
<p>手脱 Exestealth 2.72 的壳</p>
<p>看到这或许会沉迷与ESP定律当中，在这里提醒大家：<strong>Exestealth 2.72 的壳 用我们一开始提到的”懒方法脱壳“是最简单的；</strong></p>
<hr>
<p>手脱nspack（北斗）1.3 的壳</p>
<p>1、ESP定律，命令：hr ESP地址 【脱壳后程序不能正常运行】 </p>
<p>2、用 ImportREC 这个工具进行修复，修复后程序正常运行。</p>
<p><strong>另类方法脱 ASPack 2.12R 壳的技巧</strong></p>
<p>Ctrl+S 搜索：retn 0C【retn和零C 中间有个空格】 找到后向下看，如下：</p>
<p>retn 0C  push 0 //在 retn 0C 的下面  retn //在这个地方按 F2（下断） ；</p>
<p>F9（运行）</p>
<p>停止后按 一下 F8（单步）；</p>
<p>再按一下 F7（跟进） 观看这看不懂？没关系，要是我，我也看不懂，所以我早有准备；</p>
<p>详细步骤，如下（这是某程序的一部分）：</p>
<p>程序中断后来到这里：   0046B3B8 C2 oc00 retn 0C //开始F8（单步）</p>
<p>  0046B3B9 68 64584500 push registra.00455864 //这里调用来自 00455864 （OEP）  0046B3C0 C3 retn //F7(跟进) 步入到OEP</p>
<p><strong>注意</strong>：<strong>这种壳</strong>ESP<strong>不能直接脱</strong>。</p>
<p>脱FSG v2.0技巧</p>
<p>用od打开之后找到一个三跳转的地方，就是一个判断跳转语句跳过了一个jmp，用F4走到jmp的位置，单步就可以找到oep的位置，用lordpe转存之后在修复的时候还有个坑，fsg会在输入表的地方加一些无用的干扰，所以要手工定位，找到一个API，用d 地址的命令找到输入表开始的地方减去基址为rva，在判断一下大小，最后把无效函数去掉，在修复转存文件就可以了。</p>
<p>手脱PECompact 2.x</p>
<p>这个壳一般先给eax赋值然后压栈，那么一定会访问eax，所以我们运行到push eax下面，然后给eax里的地址下一个访问断点，接着不断地f9，会有一个jmp大跳转，单步跟过去就是oep</p>
<p>手脱KBys Packer</p>
<p>od载入，先走几步F8，发现了PUSHAD，这就可以用ESP了，再ESP下断点，F9一步，走到oep附近，F8，发现一个jmp大跳转，跟过去就是熟悉的入口指令，这就是oep了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-利用异常进行反调试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95/" class="article-date">
      <time datetime="2021-07-05T06:28:41.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95/">利用异常进行反调试</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-释放器分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/03/%E9%87%8A%E6%94%BE%E5%99%A8%E5%88%86%E6%9E%90/" class="article-date">
      <time datetime="2021-07-03T03:20:48.000Z" itemprop="datePublished">2021-07-03</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/03/%E9%87%8A%E6%94%BE%E5%99%A8%E5%88%86%E6%9E%90/">释放器分析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="释放器类样本-分析报告"><a href="#释放器类样本-分析报告" class="headerlink" title="释放器类样本 分析报告"></a>释放器类样本 分析报告</h1><h3 id="822f943bfb27abc5f1acd66bd76ea46b分析过程："><a href="#822f943bfb27abc5f1acd66bd76ea46b分析过程：" class="headerlink" title="822f943bfb27abc5f1acd66bd76ea46b分析过程："></a>822f943bfb27abc5f1acd66bd76ea46b分析过程：</h3><p>vt分析：</p>
<p><img src="https://i.imgur.com/okQTi3r.png"></p>
<p><img src="https://i.imgur.com/eX3dwZ7.png"></p>
<p>释放文件</p>
<p><img src="https://i.imgur.com/txZVVzR.png"></p>
<p>执行释放文件， 大多是注册表操作</p>
<p>释放文件</p>
<p><img src="https://i.imgur.com/AxVorVd.png"></p>
<h5 id="ida分析病毒样本"><a href="#ida分析病毒样本" class="headerlink" title="ida分析病毒样本"></a>ida分析病毒样本</h5><p>start函数直接发现关键位置</p>
<p><img src="https://i.imgur.com/Ky79BJF.png"></p>
<p>三个关键API，CreateFileA先创建⽂件，WriteFile写⼊⽂件，最后ShellExecuteA执⾏⽂件。</p>
<p>静调没发现什么文件信息.</p>
<h5 id="动调过程："><a href="#动调过程：" class="headerlink" title="动调过程："></a>动调过程：</h5><p>单步调，发现MZ，转到内存窗口查看，是pe文件</p>
<p><img src="https://i.imgur.com/Rf4v5CF.png"></p>
<p>接着调可以发现字符串，推测是上述pe的文件名</p>
<p><img src="https://i.imgur.com/9NYIERf.png"></p>
<p>发现释放文件的路径</p>
<p><img src="https://i.imgur.com/U6aB9Vu.png"></p>
<p><img src="https://i.imgur.com/Rs7lOxO.png"></p>
<p>在该目录中发现rename-me.exe，此时数据还没写入，文件大小0kb</p>
<p><img src="https://i.imgur.com/qIYc8Q9.png"></p>
<p>调到writefile函数执行，push eax，跟到内存窗口中，是写入文件的数据，比对两次发现的数据得到释放的文件没有经过任何加密操作。</p>
<p><img src="https://i.imgur.com/wZoBzLE.png"></p>
<p>ShellExecuteA执行rename-me.exe </p>
<p><img src="https://i.imgur.com/H9Vc3no.png"></p>
<p>跳转到40211B  向下跳发现另一个字符串，释放又一个可执行文件1205432525.exe</p>
<p><img src="https://i.imgur.com/5r5aVGB.png"></p>
<p>与rename-me.exe在同一目录下</p>
<p><img src="https://i.imgur.com/lBhHCvt.png"></p>
<p><img src="https://i.imgur.com/hMQIwEp.png"></p>
<p><img src="https://i.imgur.com/DLIXWgB.png"></p>
<p>最终写进可执行文件中的数据，与前面看到的进行对比，发现数据也没有进行加密</p>
<h5 id="提取过程："><a href="#提取过程：" class="headerlink" title="提取过程："></a>提取过程：</h5><p>既然释放的文件直接存储在pe的数据段中，分析pe格式，直接提取文件</p>
<p>参考这个</p>
<p><img src="file:///C:\Users\lenovo\AppData\Roaming\Tencent\QQ\Temp[5UQ[BL(6~BS2JV6W}N6[%S.png" alt="img"><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-125674.htm">https://bbs.pediy.com/thread-125674.htm</a></p>
<p>提取结果：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210703112852985.png" alt="image-20210703112852985"></p>
<p>把提取的文件与代码运行释放的文件和动调过程中在内存窗口观察到的内容进行对比，一致，提取成功。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE/pe资源提取" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/" class="article-date">
      <time datetime="2021-07-01T09:05:13.000Z" itemprop="datePublished">2021-07-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/">pe资源提取</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> 最近分析的病毒样本  ，是释放器类型的，接触到的一类简单的释放器样本，数据不进行加密直接存在pe资源中，想办法把pe文件资源提取出来存在文件中，或者是弄个类似resource hacker 那种，提取资源文件。</p>
<h2 id="pe文件资源提取出来存在文件中"><a href="#pe文件资源提取出来存在文件中" class="headerlink" title="pe文件资源提取出来存在文件中"></a>pe文件资源提取出来存在文件中</h2><p>1.调试器后拷贝文件</p>
<p>释放器释放文件会用到writefile函数  ，可以在用调试器调试过程中，在wirtefile之后，直接拷贝文件，在对后续样本进行分析。</p>
<p>2.利用ida脚本</p>
<p>需要知道写入文件的地址，文件的大小</p>
<p>利用方式：</p>
<p>创建的文件和当前idb文件在同目录下，用IDA打开一个idb文件，file–&gt;script file –&gt;xxx.idc</p>
<p>自行填写填入资源的文件名   数据地址   大小（file ，addstart，size）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> file =<span class="string">&quot;xxx.bin&quot;</span>;<span class="comment">//写入pe文件资源的文件</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> addstart=<span class="number">0</span>x。。。。。;<span class="comment">//数据的地址</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> size=<span class="number">0</span>x。。。;<span class="comment">//大小</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> hfile=openfile(file);</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        writefile(hfile,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">openfile</span><span class="params">(file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> hfile=fopen(file,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(hfile==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Message(<span class="string">&quot;create file failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> hfile ;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> hfile;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">writefile</span><span class="params">(hfile,addstart,size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret=savefile(hfile,<span class="number">0</span>,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Mesage(<span class="string">&quot;write file error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Message(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类似resource-hacker-的资源提取工具"><a href="#类似resource-hacker-的资源提取工具" class="headerlink" title="类似resource hacker 的资源提取工具"></a>类似resource hacker 的资源提取工具</h2><h3 id="pe资源相关知识"><a href="#pe资源相关知识" class="headerlink" title="pe资源相关知识"></a>pe资源相关知识</h3><h3 id="资源提取器代码实现"><a href="#资源提取器代码实现" class="headerlink" title="资源提取器代码实现"></a>资源提取器代码实现</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE/" rel="tag">PE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-HOOK" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/30/HOOK/" class="article-date">
      <time datetime="2021-05-30T04:38:14.000Z" itemprop="datePublished">2021-05-30</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/30/HOOK/">HOOK</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="HOOK技术"><a href="#HOOK技术" class="headerlink" title="HOOK技术"></a>HOOK技术</h1><p>1.原理</p>
<p>修改api函数</p>
<p>unhook</p>
<p>恢复修改</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iiprogram/article/details/1585922?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">必备绝技–Hook大法( 上 )_iiprogram的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37552052/article/details/81453591">Windows Hook原理与实现_安全杂货铺-CSDN博客_hook</a></p>
<p>1.用户模式Hook</p>
<p>IAT-hooking</p>
<p>先找到自己需要hook的函数，然后把目标函数的地址改成我们自己的hook函数，最后在恢复到目标函数的地址(unhook)</p>
<p>如果是通过动态加载的就不行了<br>因为动态加载的dll的API不在iat中,而是动态生成的.</p>
<p>（四）局限性：１当程序运用一种叫<code>late-demand binding</code>技术，函数被调用时才定位地址，这样以来就不能在IAT中定位目标函数地址了．２当目标程序用动态加载（LoadLibrary)时，这种方法也将失效．（如果是通过动态加载的就不行了<br>因为动态加载的dll的API不在iat中,而是动态生成的.）</p>
<ol start="2">
<li>hook——ZwQuerySystemInformation</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/freesec/p/6560935.html">hook技术–代码hook - freesec - 博客园 (cnblogs.com)</a></p>
<p>3 .HotFix Hook</p>
<p>从上节对Code Hook方法的讲解中，我们会发现Code Hook存在一个效率的问题，因为每次Code Hook都要进行“挂钩+脱钩”的操作，也就是要对API的前5字节修改两次，这样，当我们要进行全局Hook的时候，系统运行效率会受影响。而且，当一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行“写”操作，这时就会程序冲突，最终引发一些错误。<br>有没有办法避免这种隐患呢？答案是有的，可以使用HotFix Hook（“热补丁”）方法。</p>
<p>5.3.1 技术原理</p>
<p>以上累出的API起始代码有如下两个明显的相似点：<br>[1]API代码以“MOV EDI,EDI”指令开始。<br>[2]API代码上方有5个NOP指令。</p>
<p>MOV EDI,EDI用于将EDI的值再次复制给EDI，这没有什么实际意义。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。所以我们就可以通过修改这7个字节来实现Hook操作。这种方法因为可以在进程处于运行状态时临时更改进程内存中的库文件，所以微软也常用这种方法来打“热补丁”。</p>
<ol start="4">
<li>Inline Hook</li>
</ol>
<p>内联Hook相比于IAT Hook，显得更简单粗暴，它直接修改内存中任意函数的代码，将其劫持至Hook API。同时，它比IAT Hook的适用范围更广，因为只要是内存中有的函数它都能Hook，而后者只能Hook IAT表里存在的函数（有些程序会动态加载函数）。</p>
<p>技术原理</p>
<p>Inline Hook的目标是系统函数，如下，左图是Hook之前的状态，procexp.exe进程调用ZwQuerySystemInformation()函数时，ZwQuerySystemInformation()的代码是正常的代码。右图是Hook后的状态，注意红框中的代码，ZwQuerySystemInformation()函数开头5个字节已被修改，变成了jmp 0x10001120，也就是我们恶意代码的地址，之后便可以开始我们的自定义操作。0x1000116A我们先进行unhook操作（脱钩），目的是将ZwQuerySystemInformation()的代码恢复。大家可能有疑惑，为什么刚修改完又要恢复回来，原因很简单，Hook的目的是当调用某个函数时，我们能劫持进程的执行流。现在我们已经劫持了进程的执行流，便可以恢复ZwQuerySystemInformation()的代码，以便我们的恶意代码可以正常调用ZwQuerySystemInformation()。执行完恶意代码后，再次挂钩，监控该函数。</p>
<p>5.通过消息钩子<br> 1．基本原理：微软自己定义了一个钩子函数，这个钩子可以钩住系统的任何一类消息，并产生相关的回调函数。比如我们设置的是键盘钩子，如果用户按下键盘的键，就可以触发一个我们自定义功能的回调函数。<br> 2．大体框架：<br> 文件1：产生特定功能的Dll，并设置钩子<br>    SetWindowsHookEx(WH_KEYBOARD, myKeyBrdFuncAd, myDllHandle, 0),</p>
<p> 文件2：将Dll设置到特定目录，隐藏等<br>    安装钩子函数，只要另一个进程按下了键，则钩子启动，加载Dll<br>    卸载钩子</p>
<p> 4．局限性：会产生Dll体，虽然没有进程，但可以通过其他工具轻易发现</p>
<ol start="6">
<li>通过创建远程线程<br> 1．一般思路：远程线程，顾名思义就是在其他进程中创建一个线程，如果这个进程是系统每次启动必须加载的，那么就能每次有注入目标。这主要通过CreateRemoteThread函数完成。<br> 2．大体框架：<br> 文件1：可以重定位的代码，或是DLL,这个代码当然是有特定目的的<br> 文件2：查找特定进程，如文件管理器，打开进程<pre><code> VirtualAllocEx函数在进程中申请分配空间
 WriteProcessMemory函数将远程线程中的代码拷贝到申请到的空间
 CreateRemoteThread函数创建远程线程
</code></pre>
</li>
</ol>
<p>4.局限性：有时会遇到申请内存失败。</p>
<p> 总结：以上的几种方法，相互配合将发挥更为强大的力量。但由于都是动作在ring3，有着先天不足的缺点，都逃不过内核模块的监测。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CVE-2017-11882漏洞复现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/25/CVE-2017-11882%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" class="article-date">
      <time datetime="2021-05-25T10:44:04.000Z" itemprop="datePublished">2021-05-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/25/CVE-2017-11882%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">CVE-2017-11882漏洞复现</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-进程隐藏技术" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/25/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/" class="article-date">
      <time datetime="2021-05-25T08:19:21.000Z" itemprop="datePublished">2021-05-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/25/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/">进程隐藏技术</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><code>进程隐藏的方法有很多，例如 DLL 劫持、DLL注入、代码注入、进程内存替换、HOOK API 等等。</code></p>
<h1 id="劫持ZwQuerySystemInformation函数实现进程隐藏"><a href="#劫持ZwQuerySystemInformation函数实现进程隐藏" class="headerlink" title="劫持ZwQuerySystemInformation函数实现进程隐藏"></a>劫持ZwQuerySystemInformation函数实现进程隐藏</h1><p>==HOOK API==</p>
<p><a target="_blank" rel="noopener" href="https://www.write-bug.com/article/1960.html">技术分享 - 劫持ZwQuerySystemInformation函数实现进程隐藏 (write-bug.com)</a></p>
<p>占坑 </p>
<p>等hook系统了解后在来</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaocaiju/article/details/7586795">hook zwQuerySysteminformation 隐藏进程_小驹的专栏-CSDN博客</a></p>
<h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>　　由于遍历进程通常是通过调用WIN32 API函数 EnumProcesses 或是CreateToolhelp32Snapshot 等来实现的。</p>
<p>　　通过跟踪逆向这些WIN32 API函数可知，它们内部最终是通过调用ZwQuerySystemInformation函数来检索系</p>
<p>　　统进程信息的，从而实现进程遍历操作。所以，程序只需要HOOK ZwQuerySystemInformation这一个函数就</p>
<p>　　足够了。在ZwQuerySystem Information函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程</p>
<p>　　信息进行修改，将隐藏的进程信息从中去掉再返回。因此只要是通过调用ZwQuerySystemInformation来检索</p>
<p>　　系统进程的，获取到的数据均是被篡改的，自然获取不到隐藏进程的信息，这样，指定进程就被隐藏起来了。</p>
<p><a target="_blank" rel="noopener" href="http://www.bubuko.com/infodetail-3532998.html">HOOK函数ZwQuerySystemInformation实现进程隐藏-布布扣-bubuko.com</a></p>
<h1 id="傀儡进程注入"><a href="#傀儡进程注入" class="headerlink" title="傀儡进程注入"></a>傀儡进程注入</h1><p>==也是进程内存替换==</p>
<p>之前分析的病毒 使用傀儡进程注入(进程内存替换)达到进程隐藏的目的 ，傀儡进程是将目标进程的映射文件替换为指定的映射文件,替换后的进程称之为傀儡进程;常常有恶意程序将隐藏在自己文件内的恶意代码加载进目标进程,而在加载进目标进程之前，会利用ZwUnmpViewOfSection或者NtUnmapViewOfSection进行相关设置</p>
<blockquote>
<p>流程概述：</p>
<p>直接将自身代码注入傀儡进程，不需要DLL。首先用CreateProcess来创建一个挂起的IE进程，创建时候就把它挂起。然后得到它的装载基址，使用函数ZwUnmapViewOfSection来卸载这个这个基址内存空间的数据，。再用VirtualAllocEx来个ie进程重新分配内存空间，大小为要注入程序的大小(就是自身的imagesize)。使用WriteProcessMemory重新写IE进程的基址，就是刚才分配的内存空间的地址。再用WriteProcessMemory把自己的代码写入IE的内存空间。用SetThreadContext设置下进程状态，最后使用ResumeThread继续运行IE进程。</p>
</blockquote>
<h2 id="相关技术点"><a href="#相关技术点" class="headerlink" title="相关技术点"></a>相关技术点</h2><h4 id="1-创建挂起进程"><a href="#1-创建挂起进程" class="headerlink" title="1.创建挂起进程"></a>1.创建挂起进程</h4><p>系统函数CreateProcessW中参数dwCreationFlgs传递CREATE_SUSPEND便可以创建一个挂起的进程，进程被创建之后系统会为它分配足够的资源和初始化必要的操作,(常见的操作有:为进程分配空间,加载映像文件,创建主进程,将EIP指向代码入口点,并将主线程挂起等)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateProcessA(strTargetProcess.c_str(),<span class="literal">NULL</span>,NUL <span class="literal">NULL</span>, FALSE,CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>,&amp;stSi, &amp;stPi)</span><br></pre></td></tr></table></figure>

<h4 id="2-利得到当前的线程上下文"><a href="#2-利得到当前的线程上下文" class="headerlink" title="2.利得到当前的线程上下文"></a>2.利得到当前的线程上下文</h4><p>相关的API和结构信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI GetThreadContext(</span><br><span class="line">  __in          HANDLE hThread,</span><br><span class="line">  __in_out      LPCONTEXT lpContext</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">typedef struct _CONTEXT &#123;</span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              &#x2F;&#x2F; MUST BE SANITIZED</span><br><span class="line">    DWORD   EFlags;             &#x2F;&#x2F; MUST BE SANITIZED</span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>

<p>获得线程信息代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT stThreadContext;</span><br><span class="line"> stThreadContext.ContextFlags &#x3D; CONTEXT_FULL;</span><br><span class="line"> if (GetThreadContext(stPi.hThread, &amp;stThreadContext) &#x3D;&#x3D; 0)</span><br><span class="line"> &#123;</span><br><span class="line">    return FALSE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-清空目标进程的内存空间"><a href="#3-清空目标进程的内存空间" class="headerlink" title="3.清空目标进程的内存空间"></a>3.清空目标进程的内存空间</h4><p>目标进程被初始化后，进程的映像文件也随之被加载进对应的内存空间。傀儡进程在替换之前必须将目标进程的内容清除掉。此时要用到另外一个系统未文档化的函数NtUnmapViewOfSection，需要自行从ntdll.dll中获取。该函数需要指定的进程加载的基地址，基地址即是从第2步中的上下文取得。相关的函数说明及基地址计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NtUnmapViewOfSection(</span><br><span class="line">  _In_     HANDLE ProcessHandle,</span><br><span class="line">  _In_opt_ PVOID  BaseAddress</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>ontext.Ebx+ 8 = 基地址的地址，因此从context.Ebx + 8的地址读取4字节的内容并转化为DWORD类型，既是进程加载的基地址。</p>
<h4 id="4-重新分配空间"><a href="#4-重新分配空间" class="headerlink" title="4.重新分配空间"></a>4.重新分配空间</h4><p>在第3步中，NtUnmapViewOfSection将原始空间清除并释放了，因此在写入傀儡进程之前需要重新在目标进程中分配大小足够的空间。需要用到跨进程内存分配函数VirtualAllocEx。</p>
<p>一般情况下，在写入傀儡进程之前，需要将傀儡进程对应的文件按照申请空间的首地址作为基地址进行“重定位”，这样才能保证傀儡进程的正常运行。为了避免这一步操作，可以以傀儡进程PE文件头部的建议加载基地址作为VirtualAllocEx 的lpAddress参数，申请与之对应的内存空间，然后以此地址作为基地址将傀儡进程写入目标进程，就不会存在重定位问题。关于“重定位”的原理可以自行网络查找相关资料。</p>
<h4 id="5-写入傀儡进程"><a href="#5-写入傀儡进程" class="headerlink" title="5.写入傀儡进程"></a>5.写入傀儡进程</h4><p>准备工作完成后，现在开始将傀儡进程的代码写入到对应的空间中，注意写入的时候要按照傀儡进程PE文件头标明的信息进行。一般是先写入PE头，再写入PE节，如果存在附加数据还需要写入附加数据。</p>
<h4 id="6-恢复现场并运行傀儡进程"><a href="#6-恢复现场并运行傀儡进程" class="headerlink" title="6. 恢复现场并运行傀儡进程"></a>6. 恢复现场并运行傀儡进程</h4><p>在第2步中，保存的线程上下文信息需要在此时就需要及时恢复了。由于目标进程和傀儡进程的入口点一般不相同，因此在恢复之前，需要更改一下其中的线程入口点，需要用到系统函数SetThreadContext。将挂起的进程开始运行需要用到函数ResumeThread。</p>
<h4 id="7-傀儡进程创建过程总结："><a href="#7-傀儡进程创建过程总结：" class="headerlink" title="7.傀儡进程创建过程总结："></a>7.傀儡进程创建过程总结：</h4><p>(1) CreateProcess一个进程，并挂起，即向dwCreationFlags 参数传入CREATE_SUSPENDED；</p>
<p>(2) GetThreadContext获取挂起进程CONTEXT，其中，EAX为进程入口点地址，EBX指向进程PEB;</p>
<p>(3) ZwUnmapViewOfSection卸载挂起进程内存空间数据；</p>
<p>(4) VirtualAlloc分配内存空间；</p>
<p>(5) WriteProcessMemory将恶意代码写入分配的内存；</p>
<p>(6) SetThreadContext设置挂起的进程的状态；</p>
<p>(6) ResumeThread唤醒进程运行。</p>
<p>傀儡进程是恶意软件隐藏自身代码的常用方式，在调式过程中，若遇到傀儡进程，需要将创建的子进程数据从内存中dump出来，作为PE文件单独调试，dump的时机为ResumeThead调用之前，此时傀儡进程内存数据已经完全写入，进程还未正式开始运行。</p>
<p>若dump后文件无法运行，OD加载失败，则需要做如下修复：</p>
<p>(1) FileAlignment值修改为SectionAlignment值；</p>
<p>(2) 所有section的Raw Address值修改为Virtual Address.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h1><h4 id="1-原理概述："><a href="#1-原理概述：" class="headerlink" title="1.原理概述："></a>1.原理概述：</h4><p>首先我们要了解Windows为什么可以DLL劫持呢？主要是因为Windows的资源共享机制。为了尽可能多得安排资源共享，微软建议多个应用程序共享的任何模块应该放在Windows的系统目录中，如kernel32.dll，这样能够方便找到。但是随着时间的推移，安装程序会用旧文件或者未向后兼容的新文件来替换系统目录下的文件，这样会使一些其他的应用程序无法正确执行，因此，微软改变了策略，建议应用程序将所有文件放到自己的目录中去，而不要去碰系统目录下的任何东西。<br>为了提供这样的功能，在Window2000开始，微软加了一个特性，强制操作系统的加载程序首先从应用程序目录中加载模块，只有当加载程序无法在应用程序目录中找到文件，才搜索其他目录。利用系统的这个特性，就可以使应用程序强制加载我们指定的DLL做一些特殊的工作。</p>
<p>根据前面说的Windows资源共享机制，操作系统加载程序首先从应用程序目录中加载模块。这一特性在注册表中也有体现：HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode，如果为1，搜索的顺序为：应用程序所在目录-&gt;系统目录（用GetSystemDirectory获取）-&gt;16位系统目录-&gt;Windows目录（用GetWindowsDirectory获取）-&gt;运行程序的当前目录-&gt;PATH环境变量，如果为0，搜索顺序为：应用程序所在目录-&gt;运行程序的当前目录-&gt;系统目录（用GetSystemDirectory获取）-&gt;16位系统目录-&gt;Windows目录（用GetWindowsDirectory获取）-&gt;PATH环境变量。Windows Server 2003默认值为1，Windows XP/2000默认值为0或者没有这个键值。但是不管是哪种情况，第一个搜索的肯定是应用程序的所在目录，这样就有机会让应用程序去加载我们的DLL。如果这个DLL和系统目录下的某个DLL同名，导出表也相同，功能就是加载系统目录下的那个DLL，并且将导出表转发到那个真实的DLL。这时DLL劫持就发生了。<strong>可以看出，构造一个符合上面要求的DLL，再将其放在可执行文件的目录即可轻松实现DLL劫持了。</strong></p>
<blockquote>
<p>这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下：<br>1、构造一个与系统目录下LPK.DLL一样的导出表；<br>2、加载系统目录下的LPK.DLL；<br>3、将导出函数转发到系统目录下的LPK.DLL上；</p>
<p>4、在初始化函数中加入我们要执行的代码。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30904593/article/details/96203605?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">Dll劫持漏洞详解_山清水秀iOS的博客-CSDN博客</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 Pyikaaaa
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/Pyikaaaa" target="_blank">Blog</a> ❤ Pyikaaaa
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>