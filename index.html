<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Pyikaaaa</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Pyikaaaa">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pyikaaaa">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Pyikaaaa">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Pyikaaaa" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/PE/" style="font-size: 10px;">PE</a> <a href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" style="font-size: 20px;">Pc样本分析</a> <a href="/tags/RE/" style="font-size: 15px;">RE</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/linuxRE/" style="font-size: 10px;">linuxRE</a> <a href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95-%E9%80%86%E5%90%91/" style="font-size: 10px;">反调试 逆向</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">喜新念旧   芜湖!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-PE/pe资源提取" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/" class="article-date">
      <time datetime="2021-07-01T09:05:13.000Z" itemprop="datePublished">2021-07-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/">pe资源提取</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> 最近分析的病毒样本  ，是释放器类型的，接触到的一类简单的释放器样本，数据不进行加密直接存在pe资源中，想办法把pe文件资源提取出来存在文件中，或者是弄个类似resource hacker 那种，提取资源文件。</p>
<h2 id="pe文件资源提取出来存在文件中"><a href="#pe文件资源提取出来存在文件中" class="headerlink" title="pe文件资源提取出来存在文件中"></a>pe文件资源提取出来存在文件中</h2><p>1.调试器后拷贝文件</p>
<p>释放器释放文件会用到writefile函数  ，可以在用调试器调试过程中，在wirtefile之后，直接拷贝文件，在对后续样本进行分析。</p>
<p>2.利用ida脚本</p>
<p>需要知道写入文件的地址，文件的大小</p>
<p>利用方式：</p>
<p>创建的文件和当前idb文件在同目录下，用IDA打开一个idb文件，file–&gt;script file –&gt;xxx.idc</p>
<p>自行填写填入资源的文件名   数据地址   大小（file ，addstart，size）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> file =<span class="string">&quot;xxx.bin&quot;</span>;<span class="comment">//写入pe文件资源的文件</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> addstart=<span class="number">0</span>x。。。。。;<span class="comment">//数据的地址</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> size=<span class="number">0</span>x。。。;<span class="comment">//大小</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> hfile=openfile(file);</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        writefile(hfile,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">openfile</span><span class="params">(file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> hfile=fopen(file,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(hfile==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Message(<span class="string">&quot;create file failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> hfile ;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> hfile;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">writefile</span><span class="params">(hfile,addstart,size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret=savefile(hfile,<span class="number">0</span>,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Mesage(<span class="string">&quot;write file error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Message(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类似resource-hacker-的资源提取工具"><a href="#类似resource-hacker-的资源提取工具" class="headerlink" title="类似resource hacker 的资源提取工具"></a>类似resource hacker 的资源提取工具</h2><h3 id="pe资源相关知识"><a href="#pe资源相关知识" class="headerlink" title="pe资源相关知识"></a>pe资源相关知识</h3><h3 id="资源提取器代码实现"><a href="#资源提取器代码实现" class="headerlink" title="资源提取器代码实现"></a>资源提取器代码实现</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE/" rel="tag">PE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-HOOK" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/30/HOOK/" class="article-date">
      <time datetime="2021-05-30T04:38:14.000Z" itemprop="datePublished">2021-05-30</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/30/HOOK/">HOOK</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="HOOK技术"><a href="#HOOK技术" class="headerlink" title="HOOK技术"></a>HOOK技术</h1><p>1.原理</p>
<p>修改api函数</p>
<p>unhook</p>
<p>恢复修改</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iiprogram/article/details/1585922?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">必备绝技–Hook大法( 上 )_iiprogram的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37552052/article/details/81453591">Windows Hook原理与实现_安全杂货铺-CSDN博客_hook</a></p>
<p>1.用户模式Hook</p>
<p>IAT-hooking</p>
<p>先找到自己需要hook的函数，然后把目标函数的地址改成我们自己的hook函数，最后在恢复到目标函数的地址(unhook)</p>
<p>如果是通过动态加载的就不行了<br>因为动态加载的dll的API不在iat中,而是动态生成的.</p>
<p>（四）局限性：１当程序运用一种叫<code>late-demand binding</code>技术，函数被调用时才定位地址，这样以来就不能在IAT中定位目标函数地址了．２当目标程序用动态加载（LoadLibrary)时，这种方法也将失效．（如果是通过动态加载的就不行了<br>因为动态加载的dll的API不在iat中,而是动态生成的.）</p>
<ol start="2">
<li>hook——ZwQuerySystemInformation</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/freesec/p/6560935.html">hook技术–代码hook - freesec - 博客园 (cnblogs.com)</a></p>
<p>3 .HotFix Hook</p>
<p>从上节对Code Hook方法的讲解中，我们会发现Code Hook存在一个效率的问题，因为每次Code Hook都要进行“挂钩+脱钩”的操作，也就是要对API的前5字节修改两次，这样，当我们要进行全局Hook的时候，系统运行效率会受影响。而且，当一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行“写”操作，这时就会程序冲突，最终引发一些错误。<br>有没有办法避免这种隐患呢？答案是有的，可以使用HotFix Hook（“热补丁”）方法。</p>
<p>5.3.1 技术原理</p>
<p>以上累出的API起始代码有如下两个明显的相似点：<br>[1]API代码以“MOV EDI,EDI”指令开始。<br>[2]API代码上方有5个NOP指令。</p>
<p>MOV EDI,EDI用于将EDI的值再次复制给EDI，这没有什么实际意义。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。所以我们就可以通过修改这7个字节来实现Hook操作。这种方法因为可以在进程处于运行状态时临时更改进程内存中的库文件，所以微软也常用这种方法来打“热补丁”。</p>
<ol start="4">
<li>Inline Hook</li>
</ol>
<p>内联Hook相比于IAT Hook，显得更简单粗暴，它直接修改内存中任意函数的代码，将其劫持至Hook API。同时，它比IAT Hook的适用范围更广，因为只要是内存中有的函数它都能Hook，而后者只能Hook IAT表里存在的函数（有些程序会动态加载函数）。</p>
<p>技术原理</p>
<p>Inline Hook的目标是系统函数，如下，左图是Hook之前的状态，procexp.exe进程调用ZwQuerySystemInformation()函数时，ZwQuerySystemInformation()的代码是正常的代码。右图是Hook后的状态，注意红框中的代码，ZwQuerySystemInformation()函数开头5个字节已被修改，变成了jmp 0x10001120，也就是我们恶意代码的地址，之后便可以开始我们的自定义操作。0x1000116A我们先进行unhook操作（脱钩），目的是将ZwQuerySystemInformation()的代码恢复。大家可能有疑惑，为什么刚修改完又要恢复回来，原因很简单，Hook的目的是当调用某个函数时，我们能劫持进程的执行流。现在我们已经劫持了进程的执行流，便可以恢复ZwQuerySystemInformation()的代码，以便我们的恶意代码可以正常调用ZwQuerySystemInformation()。执行完恶意代码后，再次挂钩，监控该函数。</p>
<p>5.通过消息钩子<br> 1．基本原理：微软自己定义了一个钩子函数，这个钩子可以钩住系统的任何一类消息，并产生相关的回调函数。比如我们设置的是键盘钩子，如果用户按下键盘的键，就可以触发一个我们自定义功能的回调函数。<br> 2．大体框架：<br> 文件1：产生特定功能的Dll，并设置钩子<br>    SetWindowsHookEx(WH_KEYBOARD, myKeyBrdFuncAd, myDllHandle, 0),</p>
<p> 文件2：将Dll设置到特定目录，隐藏等<br>    安装钩子函数，只要另一个进程按下了键，则钩子启动，加载Dll<br>    卸载钩子</p>
<p> 4．局限性：会产生Dll体，虽然没有进程，但可以通过其他工具轻易发现</p>
<ol start="6">
<li>通过创建远程线程<br> 1．一般思路：远程线程，顾名思义就是在其他进程中创建一个线程，如果这个进程是系统每次启动必须加载的，那么就能每次有注入目标。这主要通过CreateRemoteThread函数完成。<br> 2．大体框架：<br> 文件1：可以重定位的代码，或是DLL,这个代码当然是有特定目的的<br> 文件2：查找特定进程，如文件管理器，打开进程<pre><code> VirtualAllocEx函数在进程中申请分配空间
 WriteProcessMemory函数将远程线程中的代码拷贝到申请到的空间
 CreateRemoteThread函数创建远程线程
</code></pre>
</li>
</ol>
<p>4.局限性：有时会遇到申请内存失败。</p>
<p> 总结：以上的几种方法，相互配合将发挥更为强大的力量。但由于都是动作在ring3，有着先天不足的缺点，都逃不过内核模块的监测。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CVE-2017-11882漏洞复现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/25/CVE-2017-11882%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" class="article-date">
      <time datetime="2021-05-25T10:44:04.000Z" itemprop="datePublished">2021-05-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/25/CVE-2017-11882%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">CVE-2017-11882漏洞复现</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-进程隐藏技术" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/25/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/" class="article-date">
      <time datetime="2021-05-25T08:19:21.000Z" itemprop="datePublished">2021-05-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/25/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/">进程隐藏技术</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><code>进程隐藏的方法有很多，例如 DLL 劫持、DLL注入、代码注入、进程内存替换、HOOK API 等等。</code></p>
<h1 id="劫持ZwQuerySystemInformation函数实现进程隐藏"><a href="#劫持ZwQuerySystemInformation函数实现进程隐藏" class="headerlink" title="劫持ZwQuerySystemInformation函数实现进程隐藏"></a>劫持ZwQuerySystemInformation函数实现进程隐藏</h1><p>==HOOK API==</p>
<p><a target="_blank" rel="noopener" href="https://www.write-bug.com/article/1960.html">技术分享 - 劫持ZwQuerySystemInformation函数实现进程隐藏 (write-bug.com)</a></p>
<p>占坑 </p>
<p>等hook系统了解后在来</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaocaiju/article/details/7586795">hook zwQuerySysteminformation 隐藏进程_小驹的专栏-CSDN博客</a></p>
<h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>　　由于遍历进程通常是通过调用WIN32 API函数 EnumProcesses 或是CreateToolhelp32Snapshot 等来实现的。</p>
<p>　　通过跟踪逆向这些WIN32 API函数可知，它们内部最终是通过调用ZwQuerySystemInformation函数来检索系</p>
<p>　　统进程信息的，从而实现进程遍历操作。所以，程序只需要HOOK ZwQuerySystemInformation这一个函数就</p>
<p>　　足够了。在ZwQuerySystem Information函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程</p>
<p>　　信息进行修改，将隐藏的进程信息从中去掉再返回。因此只要是通过调用ZwQuerySystemInformation来检索</p>
<p>　　系统进程的，获取到的数据均是被篡改的，自然获取不到隐藏进程的信息，这样，指定进程就被隐藏起来了。</p>
<p><a target="_blank" rel="noopener" href="http://www.bubuko.com/infodetail-3532998.html">HOOK函数ZwQuerySystemInformation实现进程隐藏-布布扣-bubuko.com</a></p>
<h1 id="进程内存替换"><a href="#进程内存替换" class="headerlink" title="进程内存替换"></a>进程内存替换</h1><p>==也是傀儡进程注入==</p>
<p>之前分析的病毒 使用傀儡进程注入(进程内存替换)达到进程隐藏的目的 ，傀儡进程是将目标进程的映射文件替换为指定的映射文件,替换后的进程称之为傀儡进程;常常有恶意程序将隐藏在自己文件内的恶意代码加载进目标进程,而在加载进目标进程之前，会利用ZwUnmpViewOfSection或者NtUnmapViewOfSection进行相关设置</p>
<blockquote>
<p>流程概述：</p>
<p>直接将自身代码注入傀儡进程，不需要DLL。首先用CreateProcess来创建一个挂起的IE进程，创建时候就把它挂起。然后得到它的装载基址，使用函数ZwUnmapViewOfSection来卸载这个这个基址内存空间的数据，。再用VirtualAllocEx来个ie进程重新分配内存空间，大小为要注入程序的大小(就是自身的imagesize)。使用WriteProcessMemory重新写IE进程的基址，就是刚才分配的内存空间的地址。再用WriteProcessMemory把自己的代码写入IE的内存空间。用SetThreadContext设置下进程状态，最后使用ResumeThread继续运行IE进程。</p>
</blockquote>
<h2 id="相关技术点"><a href="#相关技术点" class="headerlink" title="相关技术点"></a>相关技术点</h2><h4 id="1-创建挂起进程"><a href="#1-创建挂起进程" class="headerlink" title="1.创建挂起进程"></a>1.创建挂起进程</h4><p>系统函数CreateProcessW中参数dwCreationFlgs传递CREATE_SUSPEND便可以创建一个挂起的进程，进程被创建之后系统会为它分配足够的资源和初始化必要的操作,(常见的操作有:为进程分配空间,加载映像文件,创建主进程,将EIP指向代码入口点,并将主线程挂起等)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateProcessA(strTargetProcess.c_str(),<span class="literal">NULL</span>,NUL <span class="literal">NULL</span>, FALSE,CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>,&amp;stSi, &amp;stPi)</span><br></pre></td></tr></table></figure>

<h4 id="2-利得到当前的线程上下文"><a href="#2-利得到当前的线程上下文" class="headerlink" title="2.利得到当前的线程上下文"></a>2.利得到当前的线程上下文</h4><p>相关的API和结构信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI GetThreadContext(</span><br><span class="line">  __in          HANDLE hThread,</span><br><span class="line">  __in_out      LPCONTEXT lpContext</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">typedef struct _CONTEXT &#123;</span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              &#x2F;&#x2F; MUST BE SANITIZED</span><br><span class="line">    DWORD   EFlags;             &#x2F;&#x2F; MUST BE SANITIZED</span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>

<p>获得线程信息代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT stThreadContext;</span><br><span class="line"> stThreadContext.ContextFlags &#x3D; CONTEXT_FULL;</span><br><span class="line"> if (GetThreadContext(stPi.hThread, &amp;stThreadContext) &#x3D;&#x3D; 0)</span><br><span class="line"> &#123;</span><br><span class="line">    return FALSE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-清空目标进程的内存空间"><a href="#3-清空目标进程的内存空间" class="headerlink" title="3.清空目标进程的内存空间"></a>3.清空目标进程的内存空间</h4><p>目标进程被初始化后，进程的映像文件也随之被加载进对应的内存空间。傀儡进程在替换之前必须将目标进程的内容清除掉。此时要用到另外一个系统未文档化的函数NtUnmapViewOfSection，需要自行从ntdll.dll中获取。该函数需要指定的进程加载的基地址，基地址即是从第2步中的上下文取得。相关的函数说明及基地址计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NtUnmapViewOfSection(</span><br><span class="line">  _In_     HANDLE ProcessHandle,</span><br><span class="line">  _In_opt_ PVOID  BaseAddress</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>ontext.Ebx+ 8 = 基地址的地址，因此从context.Ebx + 8的地址读取4字节的内容并转化为DWORD类型，既是进程加载的基地址。</p>
<h4 id="4-重新分配空间"><a href="#4-重新分配空间" class="headerlink" title="4.重新分配空间"></a>4.重新分配空间</h4><p>在第3步中，NtUnmapViewOfSection将原始空间清除并释放了，因此在写入傀儡进程之前需要重新在目标进程中分配大小足够的空间。需要用到跨进程内存分配函数VirtualAllocEx。</p>
<p>一般情况下，在写入傀儡进程之前，需要将傀儡进程对应的文件按照申请空间的首地址作为基地址进行“重定位”，这样才能保证傀儡进程的正常运行。为了避免这一步操作，可以以傀儡进程PE文件头部的建议加载基地址作为VirtualAllocEx 的lpAddress参数，申请与之对应的内存空间，然后以此地址作为基地址将傀儡进程写入目标进程，就不会存在重定位问题。关于“重定位”的原理可以自行网络查找相关资料。</p>
<h4 id="5-写入傀儡进程"><a href="#5-写入傀儡进程" class="headerlink" title="5.写入傀儡进程"></a>5.写入傀儡进程</h4><p>准备工作完成后，现在开始将傀儡进程的代码写入到对应的空间中，注意写入的时候要按照傀儡进程PE文件头标明的信息进行。一般是先写入PE头，再写入PE节，如果存在附加数据还需要写入附加数据。</p>
<h4 id="6-恢复现场并运行傀儡进程"><a href="#6-恢复现场并运行傀儡进程" class="headerlink" title="6. 恢复现场并运行傀儡进程"></a>6. 恢复现场并运行傀儡进程</h4><p>在第2步中，保存的线程上下文信息需要在此时就需要及时恢复了。由于目标进程和傀儡进程的入口点一般不相同，因此在恢复之前，需要更改一下其中的线程入口点，需要用到系统函数SetThreadContext。将挂起的进程开始运行需要用到函数ResumeThread。</p>
<h4 id="7-傀儡进程创建过程总结："><a href="#7-傀儡进程创建过程总结：" class="headerlink" title="7.傀儡进程创建过程总结："></a>7.傀儡进程创建过程总结：</h4><p>(1) CreateProcess一个进程，并挂起，即向dwCreationFlags 参数传入CREATE_SUSPENDED；</p>
<p>(2) GetThreadContext获取挂起进程CONTEXT，其中，EAX为进程入口点地址，EBX指向进程PEB;</p>
<p>(3) ZwUnmapViewOfSection卸载挂起进程内存空间数据；</p>
<p>(4) VirtualAlloc分配内存空间；</p>
<p>(5) WriteProcessMemory将恶意代码写入分配的内存；</p>
<p>(6) SetThreadContext设置挂起的进程的状态；</p>
<p>(6) ResumeThread唤醒进程运行。</p>
<p>傀儡进程是恶意软件隐藏自身代码的常用方式，在调式过程中，若遇到傀儡进程，需要将创建的子进程数据从内存中dump出来，作为PE文件单独调试，dump的时机为ResumeThead调用之前，此时傀儡进程内存数据已经完全写入，进程还未正式开始运行。</p>
<p>若dump后文件无法运行，OD加载失败，则需要做如下修复：</p>
<p>(1) FileAlignment值修改为SectionAlignment值；</p>
<p>(2) 所有section的Raw Address值修改为Virtual Address.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h1><h4 id="1-原理概述："><a href="#1-原理概述：" class="headerlink" title="1.原理概述："></a>1.原理概述：</h4><p>首先我们要了解Windows为什么可以DLL劫持呢？主要是因为Windows的资源共享机制。为了尽可能多得安排资源共享，微软建议多个应用程序共享的任何模块应该放在Windows的系统目录中，如kernel32.dll，这样能够方便找到。但是随着时间的推移，安装程序会用旧文件或者未向后兼容的新文件来替换系统目录下的文件，这样会使一些其他的应用程序无法正确执行，因此，微软改变了策略，建议应用程序将所有文件放到自己的目录中去，而不要去碰系统目录下的任何东西。<br>为了提供这样的功能，在Window2000开始，微软加了一个特性，强制操作系统的加载程序首先从应用程序目录中加载模块，只有当加载程序无法在应用程序目录中找到文件，才搜索其他目录。利用系统的这个特性，就可以使应用程序强制加载我们指定的DLL做一些特殊的工作。</p>
<p>根据前面说的Windows资源共享机制，操作系统加载程序首先从应用程序目录中加载模块。这一特性在注册表中也有体现：HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode，如果为1，搜索的顺序为：应用程序所在目录-&gt;系统目录（用GetSystemDirectory获取）-&gt;16位系统目录-&gt;Windows目录（用GetWindowsDirectory获取）-&gt;运行程序的当前目录-&gt;PATH环境变量，如果为0，搜索顺序为：应用程序所在目录-&gt;运行程序的当前目录-&gt;系统目录（用GetSystemDirectory获取）-&gt;16位系统目录-&gt;Windows目录（用GetWindowsDirectory获取）-&gt;PATH环境变量。Windows Server 2003默认值为1，Windows XP/2000默认值为0或者没有这个键值。但是不管是哪种情况，第一个搜索的肯定是应用程序的所在目录，这样就有机会让应用程序去加载我们的DLL。如果这个DLL和系统目录下的某个DLL同名，导出表也相同，功能就是加载系统目录下的那个DLL，并且将导出表转发到那个真实的DLL。这时DLL劫持就发生了。<strong>可以看出，构造一个符合上面要求的DLL，再将其放在可执行文件的目录即可轻松实现DLL劫持了。</strong></p>
<blockquote>
<p>这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下：<br>1、构造一个与系统目录下LPK.DLL一样的导出表；<br>2、加载系统目录下的LPK.DLL；<br>3、将导出函数转发到系统目录下的LPK.DLL上；</p>
<p>4、在初始化函数中加入我们要执行的代码。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30904593/article/details/96203605?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">Dll劫持漏洞详解_山清水秀iOS的博客-CSDN博客</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-海莲花样本分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/23/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" class="article-date">
      <time datetime="2021-05-23T07:14:37.000Z" itemprop="datePublished">2021-05-23</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/23/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/">海莲花样本分析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>环境：win10  offic2003 </p>
<p>工具：ida  od windbg </p>
<p><strong>MD5：</strong>e5c766ad580b5bc5f74acc8d2f5dd028c11495d2ce503de7c7a294f94583849d</p>
<p>病毒触发样本是一个含有CVE-2017-11882 漏洞的word诱导文档文件，（下一篇为复现文章：栈溢出）</p>
<p>用office2003 sp3  打开文档   </p>
<p><img src="https://i.imgur.com/C6GWj7P.png"></p>
<p>被defender拦截 ， 查看内容，在C:\Users\lenovo\AppData\Roaming\Microsoft-Windows-DiskDiagnosticResolver_2021325962 目录下 有三个文件 ，均是 文档释放的</p>
<p><img src="https://i.imgur.com/qXfIs4z.png"></p>
<p>病毒触发样本是一个含有CVE-2017-11882 漏洞的word诱导文档文件，在用符合该CVE漏洞版本的office打开该诱导文档后，诱导文件会触发该CVE漏洞执行一段shellcode从诱导文件的二进制资源段中释MicrosoftWindowsDiskDiagnosticResolver.exe、OUTLFLTR.DAT、rastls.dll 3个文件</p>
<p>MicrosoftWindowsDiskDiagnosticResolver.exe 是 有微软签名的白文件</p>
<p><img src="https://i.imgur.com/vnJ990b.png"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" rel="tag">Pc样本分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Thallium病毒分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/11/Thallium%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/" class="article-date">
      <time datetime="2021-05-11T07:13:56.000Z" itemprop="datePublished">2021-05-11</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/11/Thallium%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/">Thallium病毒分析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>样本类型：doc</p>
<p>样本利用方式：宏代码利用</p>
<p><img src="https://i.imgur.com/ghxLpqB.png"></p>
<p>原始病毒样本是通过 宏代码 利用  然后远程连接c2服务器  进行下载.so文件  </p>
<p>把通过c2 服务器下载的 payload 后缀名改为.exe</p>
<p>直接分析.exe 文件  后续的payload文件</p>
<p>下载的TEMP.so为exe文件，md5为：                               f160c057fded2c01bfdb65bb7aa9dfcc    </p>
<p>行为分析：用process monitor 监测 payload的行为 ，设置过滤器  重命名为 tt.exe </p>
<p>可以看到一些对文件的操作 ， 还有注册表之类的</p>
<p>主要行为：</p>
<p>在c：programdata \a7963 下  拷贝自身过去</p>
<p><img src="https://i.imgur.com/NUzQiPo.png"></p>
<p><img src="https://i.imgur.com/vysRksB.png"></p>
<p>查壳  无壳 </p>
<p>分析过程：</p>
<p>1.查了资料后  知道这是 MFC的程序 ，看代码的特征，确实是MFC独有的</p>
<p>2.行为分析的时候（检测行为时）也可以感受到 在运行之后  有个明显的时间差  才有弹窗</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210511210004487.png" alt="image-20210511210004487"></p>
<p>大循环   造成延迟的主要原因</p>
<p>0x0BAADBEEF —-&gt;   3131948783 </p>
<p>VirtualProtect：</p>
<p>当做对应之 Win32 函数的逻辑包装函数。VirtualProtect 的 Win32 实作会在呼叫处理序的虚拟位址空间里，变更认可页面区域上的保护。</p>
<p><img src="https://i.imgur.com/88Oz8Cu.png"></p>
<p>0x40 : 启用对已提交页区域的执行、读和写访问  </p>
<p><strong>循环结束之后，先用VirtualProtect函数更改0x422548到0x42A548的内存属性为0x40，也就是可读可写可执行，</strong></p>
<p>之后调用401670 函数，函数不能反汇编出来，直接看汇编代码</p>
<p><img src="https://i.imgur.com/yuMSb4U.png"></p>
<p><img src="https://i.imgur.com/WuRgdAB.png"></p>
<p><img src="https://i.imgur.com/CR5idIG.png"></p>
<p><img src="https://i.imgur.com/gHrciG0.png"></p>
<p>加载有效地址（load effective address）指令就是lea,他的指令形式就是从内存读取数据到寄存器，但是实际上他没有引用内存，而是将有效地址写入到目的的操作数</p>
<p><img src="https://i.imgur.com/eunlYQg.png"></p>
<p>直接在427068 处下断点  就是下不下来 ，在4012A2 处下断点，之后f8   查看407068处的汇编  发现内容已经改变</p>
<p><img src="https://i.imgur.com/tvwUVHd.png"></p>
<p><img src="https://i.imgur.com/4bg5fS3.png"></p>
<p>前：</p>
<p><img src="https://i.imgur.com/G6wIcJg.png"></p>
<p>后：</p>
<p><img src="https://i.imgur.com/8t69XTI.png"></p>
<p>对 00427068下断点   断下来了！！！！！！！！</p>
<p>一步步跟一下 看看解密后的内容都干了什么</p>
<p><img src="https://i.imgur.com/cKFZ6FZ.png"></p>
<p>当执行 00427115 的指令时  发现很大的延迟 。回车跟进 004255c8 函数  看一下内容：</p>
<p><img src="https://i.imgur.com/KPvrYJI.png"></p>
<p>熟悉的大循环</p>
<p>返回上级函数，接着向下跟，观察寄存器的值的变化，</p>
<p><img src="https://i.imgur.com/CDoypKT.png"></p>
<p>出现字符串</p>
<p><img src="https://i.imgur.com/kRS26EG.png"></p>
<p>疑似解密  具体不清楚干啥 接着跟</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210513201316844.png" alt="image-20210513201316844"></p>
<p>运行到这的时候  弹出cmd窗口，速度太快 截不到图</p>
<p>跟进函数 004236A8内部 ： 一步步简单跟一下 </p>
<p><img src="https://i.imgur.com/jIB0CqP.png"></p>
<p>00423827处    重新创建自身进程</p>
<p>0042384e zwqueryinformationprocess</p>
<p><img src="https://i.imgur.com/C3AShnC.png"></p>
<p><img src="https://i.imgur.com/dc2Qkrr.png"></p>
<p><img src="https://i.imgur.com/xmm4m3U.png"></p>
<p>0042442A处 创建傀儡进程</p>
<p><img src="https://i.imgur.com/HHWluCv.png"></p>
<p>后面的内存操作与shellcode无关啊</p>
<p>424488 内存操作  干什么的  </p>
<p>424475</p>
<p><img src="https://i.imgur.com/iIdBhdd.png"></p>
<p><img src="https://i.imgur.com/pkTklUH.png"></p>
<p>找解密的文件存在哪了：</p>
<p><img src="https://i.imgur.com/SA7CdiB.png"></p>
<p>参数：注意   参数压栈要倒着看</p>
<p>409cb0</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210514174536373.png"></p>
<h1 id="总结断点："><a href="#总结断点：" class="headerlink" title="总结断点："></a>总结断点：</h1><p>004012a2  内存解密前</p>
<p>00427068  解密后的 enum。。。回调函数 </p>
<p>00427115   大循环</p>
<p>004245c0</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515145250754.png" alt="image-20210515145250754"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515145610210.png" alt="image-20210515145610210"></p>
<p><img src="https://i.imgur.com/JpOFFSt.png"></p>
<p>看下virtualallocex的 返回值  lpmen</p>
<p>这也是 eip指向的地址</p>
<p>先写进内存  在 改eip  为啥是  先set  改eip在写进内存     不可能的  肯定先  写进内存 在设置eip啊</p>
<h1 id="线程context"><a href="#线程context" class="headerlink" title="线程context"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/a-s-m/p/12349816.html">线程context</a></h1><p>线程切换的时候，要保存当前运行状态，以便后续切换回来</p>
<p>CONTEXT结构体保存的是一堆寄存器</p>
<p>两个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetThreadContext(HANDLE hThread,const CONTEXT *lpContext);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetThreadContext(HANDLE hThread,LPCONTEXT lpContext);</span><br></pre></td></tr></table></figure>





<p>找解密出的shellcode的位置</p>
<p>dump下来  分析：</p>
<p>为啥 resumethread后   dump不出  shellcode  </p>
<p>shelcode  的   内存地址  是动态分配的么 </p>
<p>肯定要在 释放内存后 dump啊</p>
<p>1.从解密部分跟</p>
<p><img src="https://i.imgur.com/yycXchp.png"></p>
<p>4243c5 getcontexthread</p>
<p>41442a setcontextthread </p>
<p>跟下中间的call  被跳过</p>
<p><img src="https://i.imgur.com/psZ9IZS.png"></p>
<p><img src="https://i.imgur.com/ZxD1iMd.png"></p>
<p><img src="https://i.imgur.com/UwrJLH8.png"></p>
<p><img src="https://i.imgur.com/e8buhMT.png"><a target="_blank" rel="noopener" href="https://i.imgur.com/e8buhMT.png">https://i.imgur.com/e8buhMT.png</a></p>
<p>!!!!!!!</p>
<p>setthreadcontext()  resumethread()</p>
<p>将新的指令指针指向添加的代码并恢复线程执行：</p>
<p>之后执行注入的部分</p>
<p>解密之后的位置：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210522124544312.png" alt="image-20210522124544312"></p>
<p>dump下来分析 </p>
<p>42442a </p>
<p>另一种找 解密的  注入的傀儡进程pe   的方法</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210522132401605.png" alt="image-20210522132401605"></p>
<p>从resumethread  中  一步步  单步跟   之后rent到  4271f3  处   看eax处  跟随到数据窗口  就是 注入的pe</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210522132650820.png" alt="image-20210522132650820"></p>
<p>压栈 eax值   pe的首地址</p>
<p><strong>重新调试 先看解密后的地址  再跟resumethread后 的地址   发现pe存的地址相同</strong></p>
<p>傀儡进程：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cssxn/article/details/97642863?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase">获取进程基址小技巧（傀儡进程）_Sven的忘却日记-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Reversess/article/details/26701553">傀儡进程内存Dump_Reverser的专栏-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30394251/article/details/96275012?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">傀儡进程脱壳三步曲_badiu_30394251的博客-CSDN博客</a></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210523215353067.png" alt="image-20210523215353067"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" rel="tag">Pc样本分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Globelmposter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/06/Globelmposter/" class="article-date">
      <time datetime="2021-05-06T12:46:10.000Z" itemprop="datePublished">2021-05-06</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/06/Globelmposter/">Globelmposter</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="GlobeImposter病毒分析报告"><a href="#GlobeImposter病毒分析报告" class="headerlink" title="GlobeImposter病毒分析报告"></a>GlobeImposter病毒分析报告</h1><h2 id="0x00-基础信息"><a href="#0x00-基础信息" class="headerlink" title="0x00 基础信息"></a>0x00 基础信息</h2><p>病毒背景：</p>
<p>这个勒索病毒关键在于加密文件</p>
<p>运行环境：win10 </p>
<p>一个勒索病毒  去微步下个样本回来</p>
<p><img src="https://i.imgur.com/bwqXvfZ.png"></p>
<h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>1.DIE查壳  无壳</p>
<p>图：</p>
<p>2.</p>
<p>图：</p>
<p><img src="https://i.imgur.com/IVzxN61.png"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210422211436355.png" alt="image-20210422211436355"></p>
<p>很多很多  </p>
<p>大概都是  创建文件 注册表相关的</p>
<p>3.简单运行：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210506204728059.png"></p>
<p><img src="https://i.imgur.com/7LuaP33.png"></p>
<p><img src="https://i.imgur.com/oDczpqb.png"></p>
<p><img src="https://i.imgur.com/Si7nMhr.png"></p>
<p>发现后缀名.Snake4444   </p>
<p>HOW_TO_BACK_FILES.txt</p>
<p>E9………..文件</p>
<p>根据提示消息  发现  E9.。。。。。文件的 后部分内容就是personal  id </p>
<h2 id="0x02-进一步分析"><a href="#0x02-进一步分析" class="headerlink" title="0x02 进一步分析"></a>0x02 进一步分析</h2><p>start函数—&gt; 跟进函数 sub_409C6B—–&gt;</p>
<p><img src="https://i.imgur.com/QzVrwfl.png"></p>
<p><img src="https://i.imgur.com/O0vpeLR.png"></p>
<p>跟进sub_408B19 函数  以下是加密解密相关的  </p>
<p>学了AES RSA  继续分析后</p>
<h3 id="sub-408B19-函数"><a href="#sub-408B19-函数" class="headerlink" title="sub_408B19 函数"></a>sub_408B19 函数</h3><p>结论：用AES内置的密钥解密出内置的RSA公钥</p>
<p>分析：</p>
<p><img src="https://i.imgur.com/PyeniKD.png"></p>
<h3 id="sub-4088F4函数"><a href="#sub-4088F4函数" class="headerlink" title="sub_4088F4函数"></a>sub_4088F4函数</h3><p>结论：计算解密出来的RSA公钥的SHA256</p>
<p>分析：</p>
<p><img src="https://i.imgur.com/lf3vN2U.png"></p>
<h3 id="下一步分析"><a href="#下一步分析" class="headerlink" title="下一步分析"></a>下一步分析</h3><p><img src="https://i.imgur.com/v26COZU.png"></p>
<p>可以看到GetModuleFileNameW 函数：获取当前程序运行的路径  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetModuleFileNameW </span><br><span class="line">参数：第一个参数为句柄（NULL则指向当前程序本身）。第二个参数用于存放地址的指针，第三个参数，系统自带的宏定义  不用管。</span><br></pre></td></tr></table></figure>

<p>接着调用两次sub_408B19函数（AES解密函数）：传入RSA公钥的SAH256值作为AES的密钥</p>
<p>第一次调用：</p>
<p><img src="https://i.imgur.com/guOM2ne.png"></p>
<p>动调发现解密出.Snake4444 ，经过简单运行观察到，这是被加密文件的后缀名</p>
<p><img src="https://i.imgur.com/ZbeEg1P.png"></p>
<p>第二次调用：</p>
<p>动调发现解密出HOW_TO_BACK_FILES.txt</p>
<p><img src="https://i.imgur.com/WlvuWJJ.png"></p>
<h3 id="sub-409ABF函数"><a href="#sub-409ABF函数" class="headerlink" title="sub_409ABF函数"></a>sub_409ABF函数</h3><p>结论：解密函数  内部有408B19 函数  还是一个 AES解密函数</p>
<p>分析： </p>
<p>第一次调用：</p>
<p>还看到下面有关于逗号的操作，不重要，不重点分析</p>
<p>动调： 跟到解密出的数据  是一些文件名</p>
<p><img src="https://i.imgur.com/4SO3hG2.png"></p>
<p>图：</p>
<p>第二次调用：同理  是利用AES解密</p>
<p>动调观看解密出的内容：</p>
<p>图：是一些目录名</p>
<p><img src="https://i.imgur.com/QK6yz1c.png"></p>
<h3 id="接着分析"><a href="#接着分析" class="headerlink" title="接着分析"></a>接着分析</h3><p>发现调用GetEnvironmentVariableW函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从调用该函数的进程的环境变量中,返回指定的变量名的值 参数：lpName:要获取值的变量名字符串指针.lpBuffer:接收变量值的字符串指针nSize:接收变量值的内存大小. 函数成功执行返回字符数量</span><br></pre></td></tr></table></figure>



<p>PathAddBackslashW函数：对应路径加上反斜杠 构成正确语法</p>
<p><img src="https://i.imgur.com/UoPlGS9.png"></p>
<p>这部分内容就是，判断运行文件的路径是否为LOACLAPPDATA环境变量路径，如果不是的话，路径后加\ 构成合理语法，根据运行程序的路径 ，获取文件名，接着拼接到路径上，之后 比较环境变量的路径值和当前程序运行的目录，判断运行文件的路径是否是LOACLAPPDATA环境变量路径 ，如果不是则把文件复制过去。如图</p>
<p><img src="https://i.imgur.com/imaZMXQ.png"></p>
<h3 id="sub-409624函数"><a href="#sub-409624函数" class="headerlink" title="sub_409624函数"></a>sub_409624函数</h3><p>结论：设置注册表的自启动</p>
<p>分析：路径相同  goto_lable_8</p>
<p>跟进函数：</p>
<p><img src="https://i.imgur.com/hDkhAS1.png"></p>
<p>发现都是注册表相关的函数，</p>
<p>RegOpenKeyExW</p>
<p>RegQueryValueExW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hKey是主键。</span><br><span class="line"></span><br><span class="line">lpValueName是键值名称。</span><br><span class="line"></span><br><span class="line">lpType是类型。</span><br><span class="line"></span><br><span class="line">lpData是读出来数据保存地方。</span><br><span class="line"></span><br><span class="line">lpcbData是读取数据多少。</span><br></pre></td></tr></table></figure>



<p>RegCreateKeyExW ：创建指定的注册表项。如果键已经存在，函数将打开它。</p>
<p>RegSetValueExW：RegSetValueEx函数在注册表项下设置指定值的数据和类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LONG RegSetValueEx(</span><br><span class="line">  HKEY hKey,           &#x2F;&#x2F; handle to key</span><br><span class="line">  LPCTSTR lpValueName, &#x2F;&#x2F; value name</span><br><span class="line">  DWORD Reserved,      &#x2F;&#x2F; reserved</span><br><span class="line">  DWORD dwType,        &#x2F;&#x2F; value type</span><br><span class="line">  CONST BYTE *lpData,  &#x2F;&#x2F; value data</span><br><span class="line">  DWORD cbData         &#x2F;&#x2F; size of value data</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RegCloseKey</p>
<p>subkey<img src="https://i.imgur.com/VV2wvdv.png"></p>
<p>总结就是 必须先通过RegOpenKey来找到Key，然后再通过RegQueryValueEx来找到这个Key中包含的Valuename。</p>
<p>如果传进来的参数（路径）不等于 根据RegQueryValueExW这个函数找到的数据 （也就是自启动没有这个路径）就创建</p>
<p>总结： 这个就是实现程序开机自启动的</p>
<h3 id="接着分析-1"><a href="#接着分析-1" class="headerlink" title="接着分析"></a>接着分析</h3><p><img src="https://i.imgur.com/WfcDyPn.png"></p>
<p>运行文件的路径是否为Public环境变量路径 ,如果是</p>
<p>{</p>
<p>sub_402828：用rsa-sha256 做参数 做些改变  然后存进一段堆空间中   也是吧rsa公钥的sha256 转为字符串</p>
<p>sub_409408：转换 </p>
<p><img src="https://i.imgur.com/4DKAiFK.png"></p>
<p>现在lpstring2  就是根据rsa公钥的SAH256值  做改变后的字符串</p>
<p><img src="https://i.imgur.com/z9poYhc.png"></p>
<p>sub_4017E8 在前面分析过 是HOW_TO BACK_FILE.txt</p>
<p>还是个转换</p>
<p>HOW_TO BACK_FILE.txt 复制给lpstring1</p>
<p>路径加反斜杠   与lpstring2进行拼接  </p>
<p>拼接后</p>
<h4 id="C-用户-public-E93F1BcB76F796……-E93F1BcB76F796……-这一串是-解密出的rsa的-sha256的值"><a href="#C-用户-public-E93F1BcB76F796……-E93F1BcB76F796……-这一串是-解密出的rsa的-sha256的值" class="headerlink" title="C:\用户\public\E93F1BcB76F796……..     E93F1BcB76F796……..   这一串是  解密出的rsa的 sha256的值"></a>C:\用户\public\E93F1BcB76F796……..     E93F1BcB76F796……..   这一串是  解密出的rsa的 sha256的值</h4><p>}</p>
<p>v7 v8 控制循环次数</p>
<h3 id="sub-409B4B函数"><a href="#sub-409B4B函数" class="headerlink" title="sub_409B4B函数"></a>sub_409B4B函数</h3><p>结论：生成user-rsa密钥对 ，并把生成的公钥和计算生成的personalid写入<strong>E93F1BcB76F796……..</strong> 文件中</p>
<p>分析：从</p>
<p>把拼接后的路径作为参数传入sub_409B4B函数 </p>
<p>创建个文件名是拼接的内容的文件 ，直接看else的内容，（因为getlasterror()   返回值只有是0的时候 操作功能完成）</p>
<p><img src="https://i.imgur.com/fSsP1DY.png"></p>
<h3 id="sub-40A116函数"><a href="#sub-40A116函数" class="headerlink" title="sub_40A116函数"></a>sub_40A116函数</h3><p>跟进sub_40A116函数</p>
<p>观察参数  有解密后的RSA公钥，有拼接后的路径名，有加密后缀Snake4444，有HOW_TO_BACK_FILES.txt</p>
<p>看到有rsa_genkey   这是个有关于RSA函数</p>
<p><img src="https://i.imgur.com/agRs9rQ.png"></p>
<p><img src="https://i.imgur.com/Kl8Ee3q.png"></p>
<p>跟进sub_409FC8—&gt;sub_409FC8—&gt; 然后调用Wirtefile 向c:..E9… 文件中写入lpstring </p>
<p>lpstring 是 生成的user rsa pub </p>
<p>根据最初简单运行时发现的HOW_TO_BACK_FILES.txt  中的提示信息可以知道  第二部分是personalid</p>
<p>personal id  的生成{</p>
<p>用生成的 user-rsa-public 和  私钥  与 一个字符串进行拼接  </p>
<p>拼接后的 字符串   被内置的黑客的 rsa公钥  加密  </p>
<p>加密后当做  personal  id  存进  E9.。。。。文件中</p>
<p>}</p>
<p>总结：sub_409B4B 函数  作用  利用RSA加密生成用户的公钥和私钥 </p>
<p> 然后把生成的personalid写入拼接后的文件</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="sub-4099A3函数"><a href="#sub-4099A3函数" class="headerlink" title="sub_4099A3函数"></a>sub_4099A3函数</h3><p>跟进函数，</p>
<p><img src="https://i.imgur.com/HiOLY4a.png"></p>
<p>遍历盘符，为每一个盘符创建一个线程，跟进startaddress—》</p>
<p><img src="https://i.imgur.com/G23Zpo2.png"></p>
<p><img src="https://i.imgur.com/rNrWlxE.png"></p>
<p>遍历文件 ，比较是不是.snake4444   是不是HOW..文件，是不是保存用户id的文件，获取当前运行的文件的路径，看是否是当前的文件本身，如果都不是，</p>
<p>跟进函数sub_408D8B</p>
<p>看不出来要干嘛  但是有个 用rsa加密的函数   猜测这个函数与加密有关</p>
<p>所以是遍历文件进行加密  ，加密成功之后，会对文件拼接一个.snake4444 后缀</p>
<p>确定sub_408D8B  函数  就是对文件及进行加密的函数</p>
<p>!!!!!!! 具体的如何实现的文件加密  太乱了  我不会 sos   </p>
<p>查看资料后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生成随机的key----》key1-----》用参数传入的生成的RSA公钥加密key1-----》调用AES进行文件的加密</span><br></pre></td></tr></table></figure>



<p>跟进函数sub_40935E</p>
<h3 id="sub-40935E函数"><a href="#sub-40935E函数" class="headerlink" title="sub_40935E函数"></a>sub_40935E函数</h3><p>结论：释放how_to_back_file.txt在相应目录</p>
<p><img src="https://i.imgur.com/15BJqbn.png"></p>
<h3 id="sub-409449函数"><a href="#sub-409449函数" class="headerlink" title="sub_409449函数"></a>sub_409449函数</h3><p>结论：创建.bat文件  （内容是解密后写进去的）执行这个文件</p>
<p><img src="https://i.imgur.com/SaZg32a.png"></p>
<p>调用8B19函数  对数据进行解密，写进bat文件中，</p>
<p>sub_409305函数：跟进有个creatprocess函数 ，应该是执行这个bat文件</p>
<p>图：   .bat内容</p>
<p>《看不懂，看的别人的》  作用：Bat会删除远程桌面连接信息文件 default.rdp，并通过wevtutil.execl命令删除日志信息</p>
<p><img src="https://i.imgur.com/U1pgMGi.png"></p>
<h3 id="sub-409509函数："><a href="#sub-409509函数：" class="headerlink" title="sub_409509函数："></a>sub_409509函数：</h3><p>结论：执行当前运行的程序的自我删除</p>
<p><img src="https://i.imgur.com/9i5QrcL.png"></p>
<h2 id="0x0x总结流程"><a href="#0x0x总结流程" class="headerlink" title="0x0x总结流程"></a>0x0x总结流程</h2><p>1.解密一些东西 为之后加密文件做准备</p>
<p>2.把自己复制到localappdata路径</p>
<p>3.设置自启动</p>
<p>4.生成名为RSA公钥的sha256的文件 文件内容是生成的user_rsa_public 和 personal id </p>
<p>5.遍历磁盘 遍历文件加密</p>
<p>6.把HOW_TO_BACK_FILE.txt文件释放到每个对应的文件下</p>
<p>7.创建个批处理文件 解密内容 执行操作</p>
<p>8.自我删除</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="文件加密的一个总结-（SOS！-不总结实在是太乱了）"><a href="#文件加密的一个总结-（SOS！-不总结实在是太乱了）" class="headerlink" title="文件加密的一个总结  （SOS！  不总结实在是太乱了）"></a>文件加密的一个总结  （SOS！  不总结实在是太乱了）</h2><p>《内置的rsa 的sha256 值》 文件中 ：</p>
<p>生成的user rsa pub</p>
<p>还有 （生成的  user  公钥私钥  与字符串拼接  再用hacker  自己的  公钥  对拼接后的  ） 字符串  进行RSA加密    密钥用的是  内置的RSA 公钥</p>
<p>文件加密  参数 用户id  和 生成的rsa公钥</p>
<p>文件加密：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生成随机的key----》key1-----》用参数传入的生成的RSA公钥加密key1-----》key 2   ----》调用AES进行文件的加密 （key2  为AES加密的，密钥）</span><br></pre></td></tr></table></figure>



<p>用参数传入的RSA公钥加密生成AES的key1，其中off_40111C为公钥指数e:固定为0x010001</p>
<p>sos！！！！！！！</p>
<h2 id="动调过程："><a href="#动调过程：" class="headerlink" title="动调过程："></a>动调过程：</h2><p>00409c84：调用MYAESDecode()    解密出 不被加密的RSA值</p>
<p>00409cfe：调用MYAESDecode()  解密出 被加密文件的后缀名.Snake4444<br>00409d13:调用MYAESDecode()  解密出 HOW_TO_BACK_FILES.txt<br>00409ad5:调用 MYAESDecode()  解密出 不被加密的文件名<br>00409ad5:调用 MYAESDecode()  解密出 不被加密的目录名</p>
<p>得等文件加密完才会断下来  不等了</p>
<p>004094b8：调用 MYAESDecode()  解密出.bat文件的内容</p>
<p>00409fa0：把生成的user_rsa_piublic 写进e9.。。文件中</p>
<p>0040A2AF：把生成的user 密钥 与  字符串进行拼接</p>
<p>0040A2DD：使用内置的rsa公钥 加密拼接好的密钥字符串</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" rel="tag">Pc样本分析</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-初步学习linux下的RE" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/06/%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0linux%E4%B8%8B%E7%9A%84RE/" class="article-date">
      <time datetime="2021-05-06T12:36:23.000Z" itemprop="datePublished">2021-05-06</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/06/%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0linux%E4%B8%8B%E7%9A%84RE/">初步学习linux下的RE</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>开始linux下的RE学习   </p>
<p>初来乍到  学习下基础的东西</p>
<p>先把yara下载了 sudo   apt-get install  yara</p>
<p>下载yara官方的规则库： </p>
<p>git clone git://github.com/Yara-Rules/rules </p>
<p>验证是否成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;rule dummy &#123; condition: true &#125;&quot; &gt; my_first_rule</span><br><span class="line"></span><br><span class="line">yara yara my_first_rule my_first_rule</span><br></pre></td></tr></table></figure>

<p>apt-get install vim</p>
<p>vim  使用：</p>
<p>简单使用：</p>
<p>vim 文件名</p>
<p>i 进入插入模式 ，esc 普通模式 ，接着按：wq   保存并退出  ：！q  不保存  直接退出 。   ：q  保存 ，可以通过ctrl + z 推出</p>
<p>cat 文件名  查看文件内容</p>
<p>gcc a.c  </p>
<p>./a.out   运行文件</p>
<p>aot-get install gdb</p>
<p>gdb：调试器</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linuxRE/" rel="tag">linuxRE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-linux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/06/linux/" class="article-date">
      <time datetime="2021-05-06T12:36:02.000Z" itemprop="datePublished">2021-05-06</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/06/linux/">linux</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-yara使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/05/05/yara%E4%BD%BF%E7%94%A8/" class="article-date">
      <time datetime="2021-05-05T13:21:38.000Z" itemprop="datePublished">2021-05-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/05/05/yara%E4%BD%BF%E7%94%A8/">yara使用</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="yara使用"><a href="#yara使用" class="headerlink" title="yara使用"></a>yara使用</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>Yara是一款用于识别恶意软件及对其行为进行分类的安全利器。Yara会根据我们自己编写的yara规则，来对可疑软件进行一个模式匹配，若可疑软件中的一些特征与我们的yara规则匹配上了，则可以初步认定可疑软件为恶意软件。</p>
<p>官方的github库地址：<a target="_blank" rel="noopener" href="https://github.com/VirusTotal/yara/releases">https://github.com/VirusTotal/yara/releases</a></p>
<p>官方文档说明： Getting started — yara 4.1.0 documentation](<a target="_blank" rel="noopener" href="https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html">https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html</a>)</p>
<h2 id="安装与使用："><a href="#安装与使用：" class="headerlink" title="安装与使用："></a>安装与使用：</h2><p>安装yara：最新版本 </p>
<p><img src="https://i.imgur.com/Zo7ktcS.png"></p>
<p>下载yara-v4.1.0-1612-win64.zip  ，将压缩包中的yarac64和yara64解压到C:\Windows目录下并分别重命名为yarac.exe和yara.exe</p>
<p>启动cmd 输入yara –help查看yara的参数</p>
<p><img src="https://i.imgur.com/jkDRvX7.png"></p>
<p>参数简单翻译：</p>
<p>yara给我们提供了一个现成的yara规则库</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Yara-Rules/rules">https://github.com/Yara-Rules/rules</a></p>
<p><strong>规则分11大类：</strong></p>
<blockquote>
<p>Antidebug_AntiVM：反调试/反沙箱类yara规则<br>Crypto：加密类yara规则<br>CVE_Rules：CVE漏洞利用类yara规则<br>email：恶意邮件类yara规则<br>Exploit-Kits：EK类yara规则<br>Malicious_Documents：恶意文档类yara规则<br>malware：恶意软件类yara规则<br>Mobile_Malware：移动恶意软件类yara规则<br>Packers：加壳类yara规则<br>utils：通用类yara规则<br>Webshells：Webshell类yara规则</p>
</blockquote>
<p>使用yara开始检测 ：</p>
<p>yara  yara规则 被检测的文件的路径  </p>
<p>使用加密类的规则对其进行扫描：</p>
<p><img src="https://i.imgur.com/1dqzLfk.png"></p>
<p>检测结果：</p>
<p>Yara的结果输出大致就是这种格式（特征+样本路径）</p>
<p>警告的原因：</p>
<p>原来是因为$c0使用了{ 0-9，a-f，A-F }的大范围匹配，导致Yara运行时间大大增长，故而输出了警告。扫描单个样本的时候差别不大，但扫描大量样本的时候就会消耗大量时间，所以我们编写yara规则的时候要多加谨慎。</p>
<p><img src="https://i.imgur.com/0nXccmb.png"></p>
<h2 id="yara规则编写："><a href="#yara规则编写：" class="headerlink" title="yara规则编写："></a>yara规则编写：</h2><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/26373.html">恶意软件模式匹配利器 - YARA - FreeBuf网络安全行业门户</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37552052/article/details/78986097">静态扫描之Yara第二话–编写yara规则（1）_安全杂货铺-CSDN博客</a></p>
<p>yarGen :yara规则生成器  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Neo23x0/yarGen">GitHub - Neo23x0/yarGen: yarGen is a generator for YARA rules</a></p>
<p>yarGen从恶意样本中提取所有ASCII和UNICODE字符串，并删除所有也出现在良性字符串数据库中的字符串。 然后使用模糊正则表达式和“Gibberish Detector”来评估和评分每个字符串，这使得yarGen能够选出最优的特征字符串。 这些字符串的前20位将被整合到最终的规则中。</p>
<p>如果不想使用或下载yarGen，也可以使用由Joe Security提供的在线工具<a target="_blank" rel="noopener" href="https://www.joesandbox.com/">Yara Rule Generator</a>，它也是基于yarGen的。</p>
<h3 id="生成高效通用的yara规则"><a href="#生成高效通用的yara规则" class="headerlink" title="生成高效通用的yara规则"></a>生成高效通用的yara规则</h3><p>如果你的规则可以检测出恶意样本，且不会匹配到合法软件，那么你的yara规则就可以算是合格了</p>
<p>yarAnalyzer:</p>
<p>yarAnalyzer是我推出的又一个强大的工具，专注于分析规则的通用性。 在创建了一个大的规则集或一个通用型的规则后，你想检查这些规则的通用性如何，便可以使用这款工具，yarAnalyzer则会输出以下结果：</p>
<ol>
<li>检测到一个以上样本的规则</li>
<li>被多条规则检测到的样本</li>
<li>没有检测到样本的规则</li>
<li>没有被检测到的样本</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Neo23x0/yarAnalyzer">https://github.com/Neo23x0/yarAnalyzer</a></p>
<h2 id="yara使用实例"><a href="#yara使用实例" class="headerlink" title="yara使用实例"></a>yara使用实例</h2><p>准备一些恶意样本 </p>
<p>进行检测</p>
<p><img src="https://i.imgur.com/Cdi64H5.png"></p>
<p>规则1 检测pe文件结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rule Mzzz</span><br><span class="line">&#123;</span><br><span class="line">	meta:</span><br><span class="line">		author &#x3D;&quot;pyikaaaa&quot;</span><br><span class="line">		description &#x3D; &quot;Look&quot;</span><br><span class="line">		date &#x3D; &quot;2020-5&quot;</span><br><span class="line">	strings:</span><br><span class="line">		$c0 &#x3D;&#123;4D 5A&#125;</span><br><span class="line">	condition:</span><br><span class="line">		$c0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><img src="https://i.imgur.com/gjuF6Js.png"></p>
<h3 id="规则2-ps-yar"><a href="#规则2-ps-yar" class="headerlink" title="规则2 ps.yar"></a>规则2 ps.yar</h3><p>用来检测cs生成的powershell马</p>
<p>提取cs生成的powershell马的特征：</p>
<p>对比32位和64位可以发现，。。。。。。。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule ps</span><br><span class="line">&#123;</span><br><span class="line">meta:</span><br><span class="line">        description&#x3D;&quot;description&quot;</span><br><span class="line">        author&#x3D;&quot;author&quot;</span><br><span class="line">        date&#x3D;&quot;2021-05&quot;</span><br><span class="line">        reference&#x3D;&quot;reference&quot;</span><br><span class="line">        hash&#x3D;&quot;hash&quot;</span><br><span class="line"></span><br><span class="line">strings:</span><br><span class="line">        $str1&#x3D;&quot;$var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)&quot;</span><br><span class="line">        $str2&#x3D;&quot;[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer, $var_code.length)&quot;</span><br><span class="line"></span><br><span class="line">condition:</span><br><span class="line">        $str1 and $str2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测：</p>
<p><img src="https://i.imgur.com/1Tr0iue.png"></p>
<p>使用webshells类检测样本</p>
<p><img src="https://i.imgur.com/hKrc7by.png"></p>
<p>使用官方给的yara规则进行 加密类的检测</p>
<p><img src="https://i.imgur.com/x3mPASB.png"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 Pyikaaaa
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/Pyikaaaa" target="_blank">Blog</a> ❤ Pyikaaaa
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>