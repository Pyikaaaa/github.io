<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Pyikaaaa</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Pyikaaaa">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pyikaaaa">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Pyikaaaa">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Pyikaaaa" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/PE/" style="font-size: 10px;">PE</a> <a href="/tags/Pc%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" style="font-size: 15px;">Pc样本分析</a> <a href="/tags/RE/" style="font-size: 20px;">RE</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/linuxRE/" style="font-size: 10px;">linuxRE</a> <a href="/tags/windoes%E5%86%85%E6%A0%B8/" style="font-size: 10px;">windoes内核</a> <a href="/tags/windows%E5%86%85%E6%A0%B8/" style="font-size: 10px;">windows内核</a> <a href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95-%E9%80%86%E5%90%91/" style="font-size: 10px;">反调试 逆向</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">喜新念旧   芜湖!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/Pyikaaaa" title="github">github</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-windows异常处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/07/windows%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
      <time datetime="2021-07-07T12:38:21.000Z" itemprop="datePublished">2021-07-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/07/windows%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">windows异常处理机制</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windoes%E5%86%85%E6%A0%B8/" rel="tag">windoes内核</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-SEH异常处理分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/07/SEH%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
      <time datetime="2021-07-07T12:26:28.000Z" itemprop="datePublished">2021-07-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/07/SEH%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/">SEH异常处理分析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>个人见解：定义好一个回调函数，然后让异常发生   异常发生时调用回调函数</p>
<p>SEH详细说明</p>
<p> SEH链</p>
<p>   SEH以链的形式存在。第一个异常处理中未处理相关异常，它就会被传递到下一个异常处理器，直到得到处理。SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_EXCEPTION_REGISTRATION_RECORD&#96;&#96;  &#96;&#96;+0x000 Next       : Ptr32 _EXCEPTION_REGISTRATION_RECORD&#96;&#96;  &#96;&#96;+0x004 Handler     : Ptr32 _EXCEPTION_DISPOSITION &#96;&#96;&#125;</span><br></pre></td></tr></table></figure>

<p>   Next成员指向下一个_EXCEPTION_REGISTRATION_RECORD结构体指针，handler成员是异常处理函数（异常处理器）。若Next成员的值为FFFFFFFF，则表示它是链表最后一个结点</p>
<p>发生异常的时候会按照(A)-&gt;(B)-&gt;(C)的顺序依次传递，直到异常被handler处理</p>
<p>handler异常处理函数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION __cdecl _except_handler (</span><br><span class="line"> &#96;&#96;EXCEPTION_RECORD   *pRecord,</span><br><span class="line"> &#96;&#96;EXCEPTION_REGISTRATION_RECORD *pFrame,</span><br><span class="line"> &#96;&#96;CONTEXT    *pContext,</span><br><span class="line"> &#96;&#96;PVOID&#96;     &#96;pValue</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p> 由系统调用，是一个回调函数，第一个参数是一个指向EXCEPTION_RECORD结构体的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef&#96; &#96;struct&#96; &#96;_EXCEPTION_RECORD &#123;&#96;&#96;  &#96;&#96;DWORD&#96; &#96;ExceptionCode;  &#96;&#96;&#x2F;&#x2F;异常代码&#96;&#96;  &#96;&#96;DWORD&#96; &#96;ExceptionFlags;&#96;&#96;  &#96;&#96;struct&#96; &#96;_EXCEPTION_RECORD *ExceptionRecord;&#96;&#96;  &#96;&#96;PVOID&#96; &#96;ExceptionAddress;  &#96;&#96;&#x2F;&#x2F;异常发生地址&#96;&#96;  &#96;&#96;DWORD&#96; &#96;NumberParameters;&#96;&#96;  &#96;&#96;ULONG_PTR&#96; &#96;ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];&#96;&#96;&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p>   异常处理函数的第三个参数是指向CONTEXT结构体的指针，CONTEXT结构体的定义如下，  CONTEXT结构体用来备份CPU的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef&#96; &#96;struct&#96; &#96;_CONTEXT &#123;&#96;&#96;  &#96;&#96;DWORD&#96; &#96;ContextFlags;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr0;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr1;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr2;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr3;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr6;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Dr7;&#96;&#96;  &#96;&#96;FLOATING_SAVE_AREA FloatSave;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegGs;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegFs;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegEs;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegDs;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Edi;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Esi;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Ebx;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Edx;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Ecx;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Eax;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Ebp;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Eip;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegCs;       &#96;&#96;&#x2F;&#x2F; MUST BE SANITIZED&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;EFlags;       &#96;&#96;&#x2F;&#x2F; MUST BE SANITIZED&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;Esp;&#96;&#96;  &#96;&#96;DWORD&#96;  &#96;SegSs;&#96;&#96;  &#96;&#96;BYTE&#96;  &#96;ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#96; &#96;&#125; CONTEXT;</span><br></pre></td></tr></table></figure>

<p>​    异常发生的时候，执行异常代码的线程就会发生中断，转而运行SEH，此时OS会把线程 CONTEXT结构体的指针传递给异常处理函数的相应参数。参数里有个eip成员。在异常处理函数中将参数eip的值（由copntext.eip传递）改为其他地址  然后返回处理函数。这样之前暂停的线程会执行新的EIP地址处的代码（反调试中经常使用这个技术）  </p>
<p>​    3 TEB.NtTib.ExceptionList</p>
<p>​    通过TEB结构体的NtTib成员可以很容易的访问进程的SEH链，TEB。</p>
<p>​     ==NtTib.ExceptionList=FS:[0]==</p>
<blockquote>
<p>FS寄存器指向当前活动线程的TEB结构（线程结构）<br>偏移 说明<br>000 指向SEH链指针<br>004 线程堆栈顶部<br>008 线程堆栈底部<br>00C SubSystemTib<br>010 FiberData<br>014 ArbitraryUserPointer<br>018 FS段寄存器在内存中的镜像地址<br>020 进程PID<br>024 线程ID<br>02C 指向线程局部存储指针<br>030 PEB结构地址（进程结构）<br>034 上个错误号</p>
</blockquote>
<p>no：</p>
<p>​    4 SEH安装/删除方法</p>
<p>​    汇编中安装使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push @MyHandler ;异常处理程序&#96;&#96;push FS:[0]    ；SEH Linked List头&#96;&#96;mov dword ptr fs:[0],esp ;添加链表</span><br></pre></td></tr></table></figure>

<p>   汇编中的删除SEH代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP &#96;&#96;DWORD&#96; &#96;PRT FS:[0] ;读取栈值并将其放入FS:[0],这里的栈值存放的下一个SEH的起始地址，执行该命令之后，就可以从栈中删除对应的SEH。&#96;&#96;ADD ESP,4</span><br></pre></td></tr></table></figure>

<p>5 od中的SEH</p>
<p>   程序在正常运行与调试运行的时候有不同的分支代码，借助SEH实现的反调试及时很多，这为代码的调试带来了很多不便，使调试更加困难。OD提供了很多调试选项，调试中发生异常的时候，调试器不会暂停，会自动将异常派送给被调试者。od中选择options-debugging options-.exception选项卡：灵活使用od的excettion选项，可以在不暂停调试器的前提下自动规避使用SEH的反调试“花招”，从而继续调试。</p>
<p>如果我们想动态跟踪这个程序，我们按Shift+F9程序就跑飞了</p>
<p>显示当异常发生之后程序接下来会怎样执行，我们只要在SE句柄前面的数值处下断就可以继续跟踪程序了</p>
<p>_Handler？？</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/thanklife/article/details/85160840">(11条消息) C++及Windows异常处理（try，catch; __try,__finally; __try, __except）_thanklife的专栏-CSDN博客___try</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-APC注入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/07/APC%E6%B3%A8%E5%85%A5/" class="article-date">
      <time datetime="2021-07-07T06:47:52.000Z" itemprop="datePublished">2021-07-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/07/APC%E6%B3%A8%E5%85%A5/">APC注入</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>具体的APC机制参考文章《APC机制》</p>
<h1 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h1><h3 id="APC-异步过程调用"><a href="#APC-异步过程调用" class="headerlink" title="APC 异步过程调用"></a>APC 异步过程调用</h3><p>异步过程调用是一种能在特定线程环境中异步执行的系统机制。</p>
<p>MSDN说,要使用SleepEx,signalObjectAndWait…..等等这些函数才会触发</p>
<h3 id="注入方法的原理"><a href="#注入方法的原理" class="headerlink" title="注入方法的原理:"></a>注入方法的原理:</h3><p>1.当对面程序执行到某一个上面的等待函数的时候,系统会产生一个中断</p>
<p>2.当线程唤醒的时候,这个线程会优先去Apc队列中调用回调函数</p>
<p>3.我们利用QueueUserApc,往这个队列中插入一个回调</p>
<p>4.插入回调的时候,把插入的回调地址改为LoadLibrary,插入的参数我们使用VirtualAllocEx申请内存,并且写入进去，写入的是Dll的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查找窗口</span></span><br><span class="line">  HWND hWnd = ::FindWindow(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;APCTest&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == hWnd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*2.获得进程的PID,当然通用的则是你把进程PID当做要注入的程序,这样不局限</span></span><br><span class="line"><span class="comment">  于窗口了.这里简单编写,进程PID可以快照遍历获取</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  DWORD dwPid = <span class="number">0</span>;</span><br><span class="line">  DWORD dwTid = <span class="number">0</span>;</span><br><span class="line">  dwTid = GetWindowThreadProcessId(hWnd, &amp;dwPid);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.打开进程</span></span><br><span class="line">  HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">  hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.成功了,申请远程内存</span></span><br><span class="line">  <span class="keyword">void</span> *lpAddr = <span class="literal">NULL</span>;</span><br><span class="line">  lpAddr = VirtualAllocEx(hProcess, <span class="number">0</span>, <span class="number">0x1000</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == lpAddr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//5.写入我们的DLL路径,这里我写入当前根目录下的路径</span></span><br><span class="line">  <span class="keyword">char</span> szBuf[] = <span class="string">&quot;MyDll.dll&quot;</span>;</span><br><span class="line">  BOOL bRet = WriteProcessMemory(hProcess, lpAddr, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!bRet)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//6.根据线程Tid,打开线程句柄</span></span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">  hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, dwTid);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == hThread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//7.给APC队列中插入回调函数</span></span><br><span class="line">  QueueUserAPC((PAPCFUNC)LoadLibraryA, hThread, (ULONG_PTR)lpAddr);</span><br><span class="line"></span><br><span class="line">  CloseHandle(hThread);</span><br><span class="line">  CloseHandle(hProcess);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PAPCFUNCpfnAPC, <span class="comment">// APC function                 指向一个用户提供的APC函数的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">HANDLEhThread, <span class="comment">// handle to thread      		指定特定线程的句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params">ULONG_PTRdwData <span class="comment">// APC function parameter		指定一个被传到pfnAPC参数指向的APC函数的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>PAPCFUNCpfnAPC  ：这个函数将在指定线程执行an alertable wait operation操作时被调用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-APC机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/07/APC%E6%9C%BA%E5%88%B6/" class="article-date">
      <time datetime="2021-07-07T05:31:32.000Z" itemprop="datePublished">2021-07-07</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/07/APC%E6%9C%BA%E5%88%B6/">APC机制</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h1><p>线程如果想结束，一定是<code>自己执行代码把自己杀死</code>，不存在别人把线程结束的情况。如何改变线程的行为，提供一个函数，让他自己去调用，这个函数就是<code>APC</code>，即异步过程调用，把提供的函数挂在APC队列中。</p>
<h2 id="APC本质"><a href="#APC本质" class="headerlink" title="APC本质"></a>APC本质</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><h4 id="线程结构体："><a href="#线程结构体：" class="headerlink" title="线程结构体："></a>线程结构体：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE  &#x2F;&#x2F;子结构体ApcState.即APC队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">nt!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead			&#x2F;&#x2F;2个APC队列（双向链表） 用户APC队列和内核APC队列 ，队列存储的都是APC函数 </span><br><span class="line">   +0x010 Process				&#x2F;&#x2F;线程所属进程或者所挂靠的进程 如果没有挂靠指向的地址与ethread 220成员threadprocess 指向地址相同</span><br><span class="line">   +0x014 KernelApcInProgress	&#x2F;&#x2F;内核APC是否正在执行</span><br><span class="line">   +0x015 KernelApcPending		&#x2F;&#x2F;是否有正在等待执行的内核APC函数 存在置为1</span><br><span class="line">   +0x016 UserApcPending		&#x2F;&#x2F;是否有正在等待执行的用户APC函数  存在置为1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> ApcListHead 两个双向链表组成 16个字节</p>
<p>改变线程执行流程，把给定的函数挂载到链表中，在某个时刻，当前线程会检查当前的函数列表，当里面有函数的时候，就会去调用。</p>
<h4 id="APC结构："><a href="#APC结构：" class="headerlink" title="APC结构："></a>APC结构：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   +0x000 Type             : UChar </span><br><span class="line">   +0x001 SpareByte0       : UChar</span><br><span class="line">   +0x002 Size             : UChar</span><br><span class="line">   +0x003 SpareByte1       : UChar</span><br><span class="line">   +0x004 SpareLong0       : Uint4B</span><br><span class="line">   +0x008 Thread           : Ptr32 _KTHREAD</span><br><span class="line">   +0x00c ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   +0x014 KernelRoutine    : Ptr32     void </span><br><span class="line">   +0x018 RundownRoutine   : Ptr32     void </span><br><span class="line">   +0x01c NormalRoutine    : Ptr32     void    指向我所提供的APC函数（想执行的函数），并不完全等APC函数的地址。</span><br><span class="line">   +0x020 NormalContext    : Ptr32 Void</span><br><span class="line">   +0x024 SystemArgument1  : Ptr32 Void</span><br><span class="line">   +0x028 SystemArgument2  : Ptr32 Void</span><br><span class="line">   +0x02c ApcStateIndex    : Char</span><br><span class="line">   +0x02d ApcMode          : Char</span><br><span class="line">   +0x02e Inserted         : UChar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过NormalRoutine成员找到我所提供的APC函数-指向apc函数）"><a href="#通过NormalRoutine成员找到我所提供的APC函数-指向apc函数）" class="headerlink" title="通过NormalRoutine成员找到我所提供的APC函数   (指向apc函数）"></a>通过NormalRoutine成员找到我所提供的APC函数   (指向apc函数）</h4><p>总结：如果我们想要改变一个线程，可以先提供一个APC，然后通过 <code>_KAPC.NormalRoutine</code> 指向我们提供的APC在哪里，再将APC存到 <code>_KTHREAD.ApcState.ApcListHead</code> 的第一个成员中</p>
<h4 id="当前的线程什么时候会执行所提供的APC函数"><a href="#当前的线程什么时候会执行所提供的APC函数" class="headerlink" title="当前的线程什么时候会执行所提供的APC函数"></a>当前的线程什么时候会执行所提供的APC函数</h4><p>发生系统调用 异常或中断返回用户空间的时候</p>
<p>执行函数KiServiceExit（检查是否有apc请求，有则KiDeliverApc处理—&gt;改变线程流程）</p>
<h3 id="APC相关函数"><a href="#APC相关函数" class="headerlink" title="APC相关函数"></a>APC相关函数</h3><h4 id="KiServiceExit"><a href="#KiServiceExit" class="headerlink" title="KiServiceExit"></a>KiServiceExit</h4><p>这个函数是系统调用 异常或中断返回用户空间的必经之路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KiServiceExit()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cmp [ kthread.apcstate.userapcpending] 0 ;检查是否有用户apc请求。。。。。不判断有无内核apc请求，有内核apc请求先处理内核的（KiDeliveApc处理），处理完了处理用户的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20191219104508974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="KiDeliveApc"><a href="#KiDeliveApc" class="headerlink" title="KiDeliveApc"></a>KiDeliveApc</h4><p>负责执行，处理 APC函数</p>
<h2 id="备用APC队列"><a href="#备用APC队列" class="headerlink" title="备用APC队列"></a>备用APC队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE</span><br><span class="line">+0x170 SavedApcState    : _KAPC_STATE 备用APC队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_KAPC_STATE     _KAPC_STATE     这两个成员的结构是完全一样的</p>
<h3 id="ApcState的含义"><a href="#ApcState的含义" class="headerlink" title="ApcState的含义"></a>ApcState的含义</h3><p>线程队列中的APC函数都是与进程相关联的，具体点说：A进程的T线程中所有的APC函数，要访问的内存地址都是A进程的。</p>
<p>但线程是可以挂靠到其他的进程：比如A进程的线程T，通过修改CR3（   CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。）改为B进程的页目录基址，就可以访问B进程的地址空间，即所谓的进程挂靠。</p>
<p>当T线程挂靠B进程后，APC队列中存储的仍然是原来的APC。具体点说，比如某个<code>APC函数</code>要读取地址为0x12345678的数据，如果此时进行读取<strong>，读到的将是B进程的地址空间，</strong>这样逻辑就错误了。</p>
<p>为了避免混乱，在T线程挂靠B进程时，会将ApcState中的值（apc队列）暂时存储到SavedApcState中，等回到原进程A时，再将APC队列恢复</p>
<p>所以，SavedApcState又称为备用APC队列</p>
<h3 id="挂靠环境下ApcState的意义"><a href="#挂靠环境下ApcState的意义" class="headerlink" title="挂靠环境下ApcState的意义"></a>挂靠环境下ApcState的意义</h3><p>在挂靠的环境下，也是可以先线程APC队列插入APC的  此时插入进ApcState队列。</p>
<p>A进程的T线程挂靠B进程  A是T的所属进程  B是T的挂靠进程<br>ApcState        B进程相关的APC函数<br>SavedApcState    A进程相关的APC函数</p>
<h3 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h3><p>创建一个傀儡进程。 DirectoryTableBase里面存的就页目录表基址。想读哪个进程，就把傀儡进程的DirectoryTableBase改成哪个进程的的。再用标准api读傀儡进程内存，很安全的，杀软还不报</p>
<h3 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">+0x040 ApcState         : _KAPC_STATE</span><br><span class="line">+0x0b8 ApcQueueable     : Pos 5, 1 Bit &#x2F;&#x2F;用于表示是否可以向线程的APC队列中插入APC</span><br><span class="line">+0x134 ApcStateIndex    : UChar &#x2F;&#x2F;0 正常状态 1 挂靠状态 2当前环境 3 插入apc时的当前环境</span><br><span class="line">+0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE  ！！&#x2F;&#x2F;两种情况下指向apc队列（apcstate savedapcstate）</span><br><span class="line">+0x170 SavedApcState    : _KAPC_STATE 备用APC队列 与acpstate一样的结构</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了操作方便（找到apc队列方便），KTHREAD结构体中定义了一个指针数组ApcStatePointer，长度为2</p>
<p>正常情况下：</p>
<blockquote>
<p> ApcStatePointer[0]指向ApcState</p>
<p> ApcStatePointer[1]指向SavedApcState</p>
</blockquote>
<p>挂靠情况下：</p>
<blockquote>
<p> ApcStatePointer[0]指向SavedApcState</p>
<p> ApcStatePointer[1]指向ApcState</p>
</blockquote>
<h3 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h3><p>ApcStateIndex用来标识当前线程处于什么状态：0正常状态 1挂靠状态</p>
<h3 id="ApcStatePointer与ApcStateIndex组合寻址-（寻址方便）"><a href="#ApcStatePointer与ApcStateIndex组合寻址-（寻址方便）" class="headerlink" title="ApcStatePointer与ApcStateIndex组合寻址 （寻址方便）"></a>ApcStatePointer与ApcStateIndex组合寻址 （寻址方便）</h3><p>正常情况下，向ApcState队列插入APC时：</p>
<blockquote>
<p> ApcStatePointer[0]指向ApcState，此时ApcStateIndex的值为0</p>
<p> ApcStatePointer[ApcStateIndex]指向ApcState</p>
</blockquote>
<p>挂靠情况下，向ApcState队列中插入APC时：</p>
<blockquote>
<p> ApcStatePointer[1]指向ApcState，此时ApcStateIndex的值为1</p>
<p> ApcStatePointer[ApcStateIndex]指向ApcState</p>
</blockquote>
<p><strong>无论什么环境下，ApcStatePointer[ApcStateIndex]指向的都是ApcState，ApcState则总是表示线程当前使用的APC状态</strong></p>
<h3 id="ApcQueueable"><a href="#ApcQueueable" class="headerlink" title="ApcQueueable"></a>ApcQueueable</h3><p>用于表示是否可以向线程的APC队列中插入APC。</p>
<p>当线程正在执行退出的代码时，会将这个值设置为0，如果此时执行插入APC的代码，在插入函数中会判断这个值的状态，如果为0，则插入失败。</p>
<h2 id="APC挂入过程"><a href="#APC挂入过程" class="headerlink" title="APC挂入过程"></a>APC挂入过程</h2><h3 id="KAPC结构"><a href="#KAPC结构" class="headerlink" title="KAPC结构"></a>KAPC结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +0x000 Type		&#x2F;&#x2F;类型  APC类型为0x12</span><br><span class="line">   +0x002 Size		&#x2F;&#x2F;本结构体的大小  0x30</span><br><span class="line">   +0x004 Spare0    	&#x2F;&#x2F;未发现被使用                             </span><br><span class="line">   +0x008 Thread 		&#x2F;&#x2F;属于哪个线程                                  </span><br><span class="line">   +0x00c ApcListEntry	&#x2F;&#x2F;APC队列挂的位置 双向链表 ，KiInsertQueueApc函数将 将KAPC挂到对应的队列中（挂到KAPC的成员ApcListEntry指向处）</span><br><span class="line">   +0x014 KernelRoutine	&#x2F;&#x2F;指向一个函数(调用ExFreePoolWithTag 释放APC)</span><br><span class="line">   +0x018 RundownRoutine&#x2F;&#x2F;略 </span><br><span class="line">   +0x01c NormalRoutine	&#x2F;&#x2F;用户APC ：用户APC 总入口  或者 内核apc ：真正的内核apc函数 ！！</span><br><span class="line">   +0x020 NormalContext	&#x2F;&#x2F;内核APC：NULL  用户APC：真正的APC函数 ！！</span><br><span class="line">   +0x024 SystemArgument1&#x2F;&#x2F;APC函数的参数	</span><br><span class="line">   +0x028 SystemArgument2&#x2F;&#x2F;APC函数的参数</span><br><span class="line">   +0x02c ApcStateIndex	&#x2F;&#x2F;APC函数挂哪个队列，有四个值：0 1 2 3</span><br><span class="line">   +0x02d ApcMode	&#x2F;&#x2F;当前的APC是用户APC还是内核APC</span><br><span class="line">   +0x02e Inserted	&#x2F;&#x2F;当前的KAPC结构体是否已经插入到APC队列 挂入前：0  挂入后  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Type ：类型。在Windows里，任何一种内核对象都有一个编号，这个编号用来标识你是属于哪一种类型，APC本身也是一种内核对象，它也有一个编号，是0x12</li>
<li>Thread：每一个线程都有自己的APC队列，这个成员指定了APC属于哪一个线程</li>
<li>ApcListEntry：APC队列挂的位置，是一个双向链表，通过这个双向链表可以找到下一个APC</li>
<li>NormalRoutine：如果当前是内核APC，通过这个值找到的就是真正的内核APC函数；如果当前的APC是用户APC，那么这个位置指向的是用户APC总入口，通过这个总入口可以找到所有用户提供的APC函数<br>NormalContext：如果当前是内核APC，通过这个值为空；如果当前的APC是用户APC，那么这个值指向的是真正的用户APC函数</li>
</ul>
<h3 id="挂入过程"><a href="#挂入过程" class="headerlink" title="挂入过程"></a>挂入过程</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-G9mKCBcJ-1625635962417)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210706195310593.png)]</p>
<h3 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VOID KeInitializeApc</span><br><span class="line">(</span><br><span class="line">	IN PKAPC Apc,&#x2F;&#x2F;KAPC指针</span><br><span class="line">	IN PKTHREAD Thread,&#x2F;&#x2F;目标线程</span><br><span class="line">	IN KAPC_ENVIRONMENT TargetEnvironment,&#x2F;&#x2F;0 1 2 3四种状态</span><br><span class="line">	IN PKKERNEL_ROUTINE KernelRoutine,&#x2F;&#x2F;销毁KAPC的函数地址</span><br><span class="line">	IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span><br><span class="line">	IN PKNORMAL_ROUTINE NormalRoutine,&#x2F;&#x2F;用户APC总入口或者内核apc函数</span><br><span class="line">	IN KPROCESSOR_MODE Mode,&#x2F;&#x2F;要插入用户apc队列还是内核apc队列</span><br><span class="line">	IN PVOID Context&#x2F;&#x2F;内核APC：NULL  用户APC：真正的APC函数</span><br><span class="line">) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-P17R77Ph-1625635962418)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210706201058231.png)]</p>
<h3 id="ApcStateIndex-1"><a href="#ApcStateIndex-1" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h3><p>与KTHREAD(+0x134)的属性同名，但含义不一样：</p>
<p>ApcStateIndex有四个值：</p>
<p>0 原始环境-&gt;插入到当前线程的所属进程APC队列，不管是否挂靠都插入到当前线程的所属进程。<br>1 挂靠环境<br>2 当前环境-&gt;插入到<code>当前进程</code>的APC队列，如果没有挂靠，当前进程则是父进程，如果挂靠了，当前进程就是挂靠进程</p>
<p>初始化时的值</p>
<p>3 <code>插入APC时的</code>当前环境-&gt;<code>线程随时处于切换状态</code> 当值为3时，在插入APC之前会判断当前线程是否处于挂靠状态 再进行APC插入<br>插入时的值</p>
<h3 id="KiInsertQueueApc"><a href="#KiInsertQueueApc" class="headerlink" title="KiInsertQueueApc"></a>KiInsertQueueApc</h3><ol>
<li>根据KAPC结构中的ApcStateIndex找到对应的APC队列</li>
<li>再根据KAPC结构中的ApcMode确定是用户队列还是内核队列</li>
<li>将KAPC挂到对应的队列中，挂到KAPC的==ApcListEntry==处 ？？？？？？  </li>
<li>再根据KAPC结构中的Inserted置1，标识当前的KAPC为已插入状态</li>
<li>修改KAPC_STATE结构中的KernelApcPending/UserApcPending</li>
</ol>
<h2 id="内核APC的执行过程"><a href="#内核APC的执行过程" class="headerlink" title="内核APC的执行过程"></a>内核APC的执行过程</h2><p>异步过程调用</p>
<p>内核APC执行流程总结：</p>
<p>判断第一个链表(内核APC队列)是否为空<br>判断KTHREAD.ApcState.KernelApcInProgress(是否正在执行内核APC)是否为1<br>判断是否禁用内核APC(KTHREAD.KernelApcDisable是否为1)<br>将当前KAPC结构体从链表中摘除<br>执行KAPC.KernelRoutine指定的函数 释放KAPC结构体占用的空间<br>将KTHREAD.ApcState.KernelApcInProgress设置为1 标识正在执行内核APC<br>执行真正的内核APC函数(KAPC.NormalRoutine)<br>执行完毕 将KernelApcInProgress改为0</p>
<h2 id="用户APC的执行过程"><a href="#用户APC的执行过程" class="headerlink" title="用户APC的执行过程"></a>用户APC的执行过程</h2><p>当产生系统调用 中断或者异常，线程在返回用户空间前都会调用_KiServiceExit函数，在_KiServiceExit函数里会判断是否有要执行的用户APC，如果有则调用KiDeliverApc函数进行处理</p>
<p>执行用户APC时的堆栈操作<br>处理用户APC要比处理内核APC复杂的多，因为用户APC函数要在用户空间执行，这里涉及到大量的换栈操作：</p>
<p>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器 栈的位置等等，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可</p>
<p>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到真正执行APC的位置</p>
<p>每处理一个用户APC就会涉及到：内核—&gt;用户空间—&gt;再回到内核空间</p>
<p>执行用户APC最为关键的就是理解堆栈操作的细节</p>
<p>用户APC执行流程总结：</p>
<p>判断用户APC链表是否为空<br>判断第一个参数是为1，为1说明处理用户APC和内核APC<br>判断ApcState.UserApcPending(是否正在执行用户APC)是否为1<br>将ApcState.UserApcPending设置为0，表示正在处理用户APC<br>链表操作 将当前APC从用户队列中拆除<br>调用函数(KAPC.KernelRoutine)释放KAPC结构体内存空间<br>调用KiInitializeUserApc函数</p>
<p>KiInitializeUserApc函数分析：备份CONTEXT<br>线程进0环时，原来的运行环境(寄存器栈顶等)保存到_Trap_Frame结构体中，如果要提前返回3环去处理用户APC，就必须修改_Trap_Frame结构体,因为此时Trap_Frame中存储的EIP是从三环进零环时保存的EIP，而不是用户APC函数的地址</p>
<p>比如：进0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置，还有堆栈ESP也要修改为处理APC需要的堆栈。那原来的值怎么办？处理完APC后该如何返回原来的位置呢？</p>
<p>KiInitializeUserApc要做的第一件事就是备份：</p>
<p>将原来_Trap_Frame的值备份到一个新的结构体中(CONTEXT)，这个功能由其子函数KeContextFromKframes来完成</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-boWvAAVS-1625635962420)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210707133006329.png)]</p>
<p><strong>总结：</strong></p>
<ol>
<li>段寄存器 SS DS FS GS</li>
<li>修改EFLAGS寄存器</li>
<li>修改ESP</li>
<li>修改EIP-&gt;ntdll.KiUserApcDispatcher</li>
</ol>
<h3 id="ntdll-KiUserApcDispatcher函数分析"><a href="#ntdll-KiUserApcDispatcher函数分析" class="headerlink" title="ntdll.KiUserApcDispatcher函数分析"></a>ntdll.KiUserApcDispatcher函数分析</h3><ol>
<li>返回内核，如果还有用户APC，重复上面的执行过程<br>后该如何返回原来的位置呢？</li>
</ol>
<p>KiInitializeUserApc要做的第一件事就是备份：</p>
<p>将原来_Trap_Frame的值备份到一个新的结构体中(CONTEXT)，这个功能由其子函数KeContextFromKframes来完成</p>
<p>[外链图片转存中…(img-boWvAAVS-1625635962420)]</p>
<p><strong>总结：</strong></p>
<ol>
<li>段寄存器 SS DS FS GS</li>
<li>修改EFLAGS寄存器</li>
<li>修改ESP</li>
<li>修改EIP-&gt;ntdll.KiUserApcDispatcher</li>
</ol>
<h3 id="ntdll-KiUserApcDispatcher函数分析-1"><a href="#ntdll-KiUserApcDispatcher函数分析-1" class="headerlink" title="ntdll.KiUserApcDispatcher函数分析"></a>ntdll.KiUserApcDispatcher函数分析</h3><ol>
<li>返回内核，如果还有用户APC，重复上面的执行过程</li>
<li>如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体，回到0环</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows%E5%86%85%E6%A0%B8/" rel="tag">windows内核</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Trojan-Dropper.Win32.Convagent.gen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/Trojan-Dropper.Win32.Convagent.gen/" class="article-date">
      <time datetime="2021-07-05T14:03:45.440Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Trojan-Dropper-Win32-Convagent-gen"><a href="#Trojan-Dropper-Win32-Convagent-gen" class="headerlink" title="Trojan-Dropper.Win32.Convagent.gen"></a>Trojan-Dropper.Win32.Convagent.gen</h1><p>Trojan-Dropper.Win32.Convagent.gen家族：先再缓冲区读取释放⽂件的数据，将数据进行解密，解密函数40B5b0，最后创建⽂件，写⼊⽂件。</p>
<hr>
<h2 id="51f4e1aca8ece1a28c375ef06c94a60d分析"><a href="#51f4e1aca8ece1a28c375ef06c94a60d分析" class="headerlink" title="51f4e1aca8ece1a28c375ef06c94a60d分析"></a>51f4e1aca8ece1a28c375ef06c94a60d分析</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p><img src="https://i.imgur.com/xkT8m6H.png"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="patch-Guard" class="article article-type-patch" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/Guard/" class="article-date">
      <time datetime="2021-07-05T09:02:12.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/Guard/">Guard</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-脱壳" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/%E8%84%B1%E5%A3%B3/" class="article-date">
      <time datetime="2021-07-05T06:37:06.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/%E8%84%B1%E5%A3%B3/">脱壳</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h4><p>1.壳：</p>
<p>一：加壳的目的：为了隐藏程序真正的OEP（入口点），防止被破解。</p>
<p>二：加壳软件是一种在编译好可执行文件之后，为了一些特定的需求，而做的一些事情，常见需求有：</p>
<p>​        有一些版权信息需要保护起来，不想让别人随便改动</p>
<p>​        为了让程序小一点，从而方便使用（把可执行文件进行压缩使用）</p>
<p>​        给木马等软件加壳以避免杀毒软件</p>
<p>三：壳的加载过程：</p>
<p>​    一般壳的装载过程：</p>
<p>​            （1）获取壳所需要使用的API地址<br>加壳后的文件，比未加壳的文件的输入表所引入的API少（甚至只有Kernel32.dll以及GetProcAddress这个API函数）；壳实际上还需要其他API函数来完成一些事情，它为了隐藏这些API，一般只在壳的代码中用显式链接的方式来动态加载这些API</p>
<p>​            （2）解密原程序的各个区块（Section）的数据<br>壳一般是按区块加密的，那么解密的时候也是按区块解密，并且把解密的区块数据按照区块的定义放在合适的内存位置；如果加壳时用到了压缩技术，那么在解密之前，需要用对应的解压缩技术。</p>
<p>​            （3）重定位</p>
<p>​            （4）HOOK-API<br>程序文件中的输入表的作用：让Windows系统在程序运行时提供API的实际地址给程序使用，这个是在程序的第一行代码执行之前，由Windows系统完成的操作。<br>而壳一般是修改了原程序文件的输入表，然后仿照Windows系统的工作来填充输入表中的相关数据，在填充过程中，外壳就可填充HOOK-API的代码地址，从而可以间接获得程序的控制权。</p>
<p>​            （5）跳转到程序原入口点<br>这个时候，壳把控制权交还给原程序</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LrESqGdT-1625549563239)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210204180643199.png)]</p>
<p>2.什么是脱壳</p>
<p>找到程序真正的入口点（OEP）</p>
<h4 id="3-分类："><a href="#3-分类：" class="headerlink" title="3.分类："></a>3.分类：</h4><p>简单分为两类  压缩壳  加密壳</p>
<p>压缩壳只是减少程序体积对资源进行压缩，加密壳是程序输入表等等进行加密保护</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fjfs4YOc-1625549563243)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210204172527304.png)]</p>
<h4 id="4-脱壳工具"><a href="#4-脱壳工具" class="headerlink" title="4.脱壳工具"></a>4.脱壳工具</h4><p>OD   找OEP 利用插件dump也可脱壳</p>
<p> PEID/Exeinfope..   查壳</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e8937b957f4a76897a9845ae697f9ad.png"></p>
<p>ImportREC  修复的</p>
<p>LordPE  脱壳的   win10 用不了  </p>
<p>无法找到进程</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ce84b24c452bc70903f70a5af679d672.png"></p>
<p>方法：右击相应的进程, 修复镜像大小, 完整转存.</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e6cdab46ee5f0ade906607cf344c58f.png"></p>
<p>脱壳机也行</p>
<h4 id="5-预备知识："><a href="#5-预备知识：" class="headerlink" title="5.预备知识："></a>5.预备知识：</h4><p>1.PUSHAD （压栈） 代表程序的入口点,</p>
<p>●把从EAX到EDI寄存器压入堆栈，保存现场（原来的值）</p>
<p>2.POPAD （出栈） 代表程序的出口点，与PUSHAD想对应，一般找到这个OEP就在附近<br>3.OEP：程序的入口点，软件加壳就是隐藏了OEP（或者用了假的OEP/FOEP），只要我们找到程序真正的OEP，就可以立刻脱壳。</p>
<h4 id="6-步骤"><a href="#6-步骤" class="headerlink" title="6.步骤"></a>6.步骤</h4><h5 id="1-识别壳"><a href="#1-识别壳" class="headerlink" title="1.识别壳"></a>1.识别壳</h5><p>1.查壳工具</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ae2a7ab8e70eb9a30b7d0b2250e003d5.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6c99e4676ca8999a2ff38c7a21779e4.png"></p>
<p>目的：知道壳的版本和编译程序的语言和编译器</p>
<p>2.通过入口特征和区段特征来识别</p>
<p>连接器版本</p>
<p>区段</p>
<p>壳的版本</p>
<p>结合OD看入口点特征 ，需要积累 多看</p>
<p>常见入口点特征：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w_g3366/article/details/94595881">https://blog.csdn.net/w_g3366/article/details/94595881</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7f0584d2060a14bb49cdeffddd2e192a.png"></p>
<p>判断是什么语言写的 可以查看区段和入口特征:</p>
<p>(1)VC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。</p>
<p>(2)VS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。</p>
<p>(3)易语言独立编译是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同</p>
<p>(4)非独立编译比较容易识别，入口特征和模块特征都有krnln.fnr</p>
<p><strong>入口特征</strong>可以通过<a target="_blank" rel="noopener" href="http://www.52pojie.cn/thread-14986-1-1.html">OllyDBG</a>载入获得，载入后可以按一下“Ctrl+A”，让OD分析一下代码，就可以把入口点一些特征字符串分析出来，对于Shielden、Safengine、VProtect这类加壳程序都可以使用这种方法判断出来。</p>
<h5 id="2-寻找oep"><a href="#2-寻找oep" class="headerlink" title="2.寻找oep"></a>2.寻找oep</h5><h5 id="3-dump"><a href="#3-dump" class="headerlink" title="3.dump"></a>3.dump</h5><h5 id="4-修复文件"><a href="#4-修复文件" class="headerlink" title="4.修复文件"></a>4.修复文件</h5><h5 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h5><p>importREC自动修复失败 手动修复IAT</p>
<h4 id="7-方法相关知识："><a href="#7-方法相关知识：" class="headerlink" title="7.方法相关知识："></a>7.方法相关知识：</h4><h5 id="（1）ESP定律法："><a href="#（1）ESP定律法：" class="headerlink" title="（1）ESP定律法："></a>（1）ESP定律法：</h5><p><strong>堆栈平衡</strong></p>
<p>壳代码就像一个函数，进入时会开辟堆栈，保存寄存器环境，退出时会恢复堆栈，恢复寄存器。所以是堆栈平衡</p>
<p>所以 在壳代码操作了堆栈后对堆栈设置硬件访问断点，然后运行程序，当断点命中的时候，就是退出壳代码的时候</p>
<p>在其附近单步几次。就可以到达程序原始的OEP</p>
<p>❤ 第一次回到初始空栈状态就可以找到我们的OEP</p>
<p>●断点：运行到这个地方就zanting</p>
<p>●访问断点再次访问这个地方 就停</p>
<p><strong>！！注意！！</strong></p>
<p>普通软件断点用于代码段，硬件断点可以用于内存，堆栈上</p>
<h5 id="（2）内存镜像法："><a href="#（2）内存镜像法：" class="headerlink" title="（2）内存镜像法："></a>（2）内存镜像法：</h5><p>内存镜像法下的内存访问断点</p>
<p>内存断点一般分为 内存访问断点  内存写入断点</p>
<p>内存访问断点：当代码读取内存的数据的时候程序暂停</p>
<p>内存写入断点：当代码向内存中写入数据的时候程序暂停</p>
<p>❤总结：</p>
<p>第一次内存访问断点：为了让前面的部分先解码</p>
<p>第二次内存访问断点：为了让后面部分也解码完成，同时在访问代码段的时候，很可能会直接断在OEP处</p>
<h4 id="8-脱壳方法："><a href="#8-脱壳方法：" class="headerlink" title="8.脱壳方法："></a>8.脱壳方法：</h4><h5 id="方法一：单步跟踪法"><a href="#方法一：单步跟踪法" class="headerlink" title="方法一：单步跟踪法"></a>方法一：单步跟踪法</h5><p>1.用OD载入，点“不分析代码！”<br>2.单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现！（通过F4）<br>3.遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点——&gt;运行到所选）<br>4.绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现！</p>
<p>●如果让程序向上跳转，则可能程序往反方向跳转，无休无止，也就找不到OEP）</p>
<p>5.如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑飞，这样很快就能到程序的OEP<br>6.在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入<br>7.一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN的一般很快就会到程序的OEP。<br> PS:在有些壳无法向下跟踪的时候，我们可以在附近找到没有实现的大跳转，右键–&gt;“跟随”,然后F2下断，Shift+F9运行停在“跟随”的位置，再取消断点，继续F8单步跟踪。一般情况下可以轻松到达OEP！</p>
<p>❤ OD 不能在nop处下断点</p>
<h5 id="方法二：ESP定律法"><a href="#方法二：ESP定律法" class="headerlink" title="方法二：ESP定律法"></a>方法二：ESP定律法</h5><p> ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）<br>1.开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）。<br>（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）<br>2.在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车！<br>3.选中下断的地址，断点—&gt;硬件访问断点&gt;WORD断点。<br>4.按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP。</p>
<h5 id="方法三：内存镜像法"><a href="#方法三：内存镜像法" class="headerlink" title="方法三：内存镜像法"></a>方法三：内存镜像法</h5><p>1：用OD打开软件！<br>2：点击选项——调试选项——异常，把里面的忽略全部√上！CTRL+F2重载下程序！<br>3：按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的.CODE（也就是00401000处），按F2下断点！然后按SHIFT+F9（或者是在没异常情况下按F9），直接到达程序OEP！</p>
<h5 id="方法四：一步到达OEP"><a href="#方法四：一步到达OEP" class="headerlink" title="方法四：一步到达OEP"></a>方法四：一步到达OEP</h5><p>1.开始按Ctrl+F,输入：popad（只适合少数壳，包括UPX，ASPACK壳），然后按下F2，F9运行到此处<br>2.来到大跳转处，点下F8，到达OEP！</p>
<h5 id="方法五：最后一次异常法"><a href="#方法五：最后一次异常法" class="headerlink" title="方法五：最后一次异常法"></a>方法五：最后一次异常法</h5><p>1：用OD打开软件<br>2：点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序<br>3：一开始程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按SHIFT+F9到程序运行的次数m！<br>4：CTRL+F2重载程序，按SHIFT+F9（这次按的次数为程序运行的次数m-1次）<br>5：在OD的右下角我们看见有一个”SE 句柄”，这时我们按CTRL+G，输入SE 句柄前的地址！<br>6：按F2下断点！然后按SHIFT+F9来到断点处！<br>7：去掉断点，按F8慢慢向下走！<br>8：到达程序的OEP！</p>
<p>❤ 这是总结出来的一种捷径. </p>
<p> 原理就是. 最后一次异常之后就正常运行了. 这个正常运行必须是真正的OEP. 所以最后一次异常是最靠近的</p>
<h5 id="方法六：模拟跟踪法"><a href="#方法六：模拟跟踪法" class="headerlink" title="方法六：模拟跟踪法"></a>方法六：模拟跟踪法</h5><p>1：先试运行，跟踪一下程序，看有没有SEH暗桩之类<br>2：ALT+M打开内存镜像，找到（包含=SFX,imports,relocations）<br>内存镜像，项目 30<br>地址=0054B000<br>大小=00002000 (8192.)<br>Owner=check 00400000<br>区段=.aspack<br>包含=SFX,imports,relocations<br>类型=Imag 01001002<br>访问=R<br>初始访问=RWE<br>3：地址为0054B000，如是我们在命令行输入tc eip&lt;0054B000,回车，正在跟踪ing。。<br>PS:大家在使用这个方法的时候，要理解他是要在怎么样的情况下才可以使用</p>
<h5 id="方法七：“SFX”法"><a href="#方法七：“SFX”法" class="headerlink" title="方法七：“SFX”法"></a>方法七：“SFX”法</h5><p>1：设置OD，忽略所有异常，也就是说异常选项卡里面都打上勾<br>2：切换到SFX选项卡，<strong>选择“字节模式跟踪实际入口（速度非常慢）</strong>”，确定。<br>3：重载程序（如果跳出是否“压缩代码？”选择“否”，OD直接到达OEP）<br>ps:这种方法不要滥用得好，锻炼能力为妙。</p>
<p> 这里最常用的ESP定律法(堆栈平衡原理)，为什么说是ESP呢，当所有的寄存器都压入栈时(pushad)，esp地址的是指向栈顶的地址的，当壳将执行权交给源程序时，esp地址要回到pushad之前的状态，这时就可以看到esp变化了，这就是源程序的入口点。（汇编，汇编，汇编！）</p>
<p>SFX:od程序自带的调试功能，用来寻找相应的OEP</p>
<p>使用注意：SFX使用的范围是当程序载入OD之后，入口点必须是代码段之外才可以使用</p>
<p>总结：</p>
<h4 id="9-例子"><a href="#9-例子" class="headerlink" title="9.例子"></a>9.例子</h4><p>upx壳</p>
<blockquote>
<p>upx的工作原理其实是这样的：首先将程序压缩。<br>所谓的压缩包括两方面：<br>一方面在程序的开头或者其他合适的地方 插入一段代码。<br>另一方面是将程序的其他地方做压缩（也就是上面讲到的压缩）。压缩也可以叫做加密，因为压缩后的程序比较难看懂，原来的代码有很大的不同。</p>
<p>当程序执行时：实时的对程序解压缩。解压缩功能是在第一步时插入的代码完成的功能。</p>
<p>联起来就是：upx可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率。</p>
</blockquote>
<p>用upx压缩之后形式为：1–&gt;2–&gt;3–&gt;4–&gt;5–&gt;6 </p>
<p>最初代码的形式就应该是：7–&gt;8–&gt;9–&gt;5–&gt;6</p>
<p>执行时的形式变为：1–&gt;7–&gt;8–&gt;9–&gt;5–&gt;6  </p>
<p>● 1是upx插入的代码</p>
<p>●内存镜像法： </p>
<p>○需要读取2 3 4内存空间的代码，这个就会存在内存访问，然后把2 3 4 解压出来，就会有内存写入</p>
<p>○把2 看作代码段  3 看做数据段 4 看做资源段 </p>
<p>○假设解码的顺序是按照2 3 4进行</p>
<p>，<strong>第一个内存访问断点</strong>，下在4 资源段处</p>
<p>当程序断下来的时候，说明代码段2和数据段3都解码完成了</p>
<p>1 7 8 4 5 6</p>
<p>○<strong>第二个内存访问断点</strong> ，下在解压完成的代码段</p>
<p>为啥：第二次断下来的时候，4肯定解码完成了，这时候就完成了所有解码，</p>
<p>1 7 8 9 5 6</p>
<p>接下来就是找OEP了，OEP在代码段7中的代码中，所以我们下的是代码段的访问断点，达到OEP就会访问代码段，所以就可以找到OEP进而完成脱壳</p>
<blockquote>
<p>手脱upx方法：</p>
<p>1.单步跟踪</p>
<p>2.一步到达（利用popad）</p>
<p>3.esp定律</p>
<p>4.内存镜像法</p>
</blockquote>
<h4 id="10-dump"><a href="#10-dump" class="headerlink" title="10.dump"></a>10.dump</h4><p>利用od自带的插件ollydump完成脱壳</p>
<h4 id="11-修复文件"><a href="#11-修复文件" class="headerlink" title="11.修复文件"></a>11.修复文件</h4><p>用importREC修复导入表</p>
<p>前提（已经找到OEP）</p>
<p>1、脱壳在当前进程,如脱壳出来的程序不能运行，提示无法定位程序输入点，需要使用<br>importREC修复导入表。<br>2、打开importREC，选正ollydbg正在调试的进程，填入正确的OEP,点ITA AutoSearch，<br>如oep正确将得到正确提示，点GetImport，得到正确的导入表。点Fix Dump，选择脱壳<br>出来的保存文件，Done!（修正后的程序为原程序名后加一下划线，原程序不会被修改。） </p>
<h4 id="12-emmm"><a href="#12-emmm" class="headerlink" title="12.emmm"></a>12.emmm</h4><p>如果直接Dump文件，修复导入表会发现程序仍然不能正常运行，那么他就不是一个单纯的压缩壳，壳中加密技术一般有IAT加密，混淆花指令，偷取OEP,反调试，代码虚拟化</p>
<p>importREC自动修复失败 手动修复IAT：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/5315hejialei/p/7060315.html">https://www.cnblogs.com/5315hejialei/p/7060315.html</a></p>
<p>原理：</p>
<p>程序的IAT是连续的排列的，所以我们只需要找到IAT的起始位置和末位置，就可以确定IAT的地址和大小。在压缩壳中，我们只要找一个调用系统的API的Call的地址，然后在数据窗口中查找，确定IAT起始和结束地址。然后在OD中手动修复</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://img-blog.csdnimg.cn/2020112721264018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MTEzOQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>手脱各种壳：</p>
<p>手脱 <strong>UPX 壳</strong>的捷径</p>
<p>1、直接ESP定律</p>
<p>2、用我们已开始提到的”关键提示“。</p>
<p> 具体操作：OD载入程序后，直接Ctrl+F，输入 POPAD ;</p>
<p>点确定后 来到这个命令所在的位置。按F2，在这个地方下断；</p>
<p>再按F9（运行）；</p>
<p>停止后，按F2取消刚才下的断点。再F8单步！</p>
<p>手脱 <strong>ASPCK</strong> 的壳</p>
<p>脱这个壳用ESP定律，还是相对快捷的。</p>
<p>可以用载入程序后，第二行（是一个CALL）那里面的ESP。 //多数程序这个壳的第二行都是一个CALL 在左OD左下角的命令行中，输入命令：hr ESP地址（如 hr 0012FFA4）；</p>
<p>F9 运行。</p>
<p>然后从OD”调试菜单“中的”硬件断点“<strong>这一项将刚才下的断点删除</strong>，这点很重要！最后F8单步！</p>
<p>用内存镜像法手脱FSG 1.33 和 PCshrink 的壳</p>
<p>1、忽略所有异常 </p>
<p>2、Alt+M 打开内存镜像，找到第一个 ”.rsrc“ </p>
<p>3、F2（下断），F9（运行） </p>
<p>4、Alt+M 打开内存镜像，找到”Code“段；</p>
<p> 5、F2（下断），Shift+F9【这点一定要记住，切记是 Shift+F9】运行；</p>
<p> 6、先按F8，再按下F4，直接到达OEP</p>
<p>PEpack 1.0 和 WinUpack 0.37-0.39 和 RLPack v.1.14-16</p>
<p>用esp定律</p>
<p>手脱 JDpack 壳</p>
<p>脱这个壳推荐使用内存镜像法 。</p>
<p>手脱 PEDiminisher ；Dxpack 0.86 ；</p>
<p>32lite 0.03a ；PEtite 2.2 这几种壳的简单方法</p>
<p>脱PEDiminisher ；Dxpack 0.86 ；</p>
<p>这两种壳的时候，直接用之前讲到的ESP定律，即可完美脱壳。命令：【hr ESP地址】</p>
<p><strong>用ESP脱 32lite 0.03a 后 要注意的是，需要用 ImportREC 这个工具进行修复。</strong>如：00410D50 在输入框中输入 10D50 就可以了【004舍去】</p>
<p><strong>在用ESP定律脱 PEtite 2.2 的时候，推荐选择 Pushad 下面那行地址中的 ESP</strong></p>
<p>手脱 Exestealth 2.72 的壳</p>
<p>看到这或许会沉迷与ESP定律当中，在这里提醒大家：<strong>Exestealth 2.72 的壳 用我们一开始提到的”懒方法脱壳“是最简单的；</strong></p>
<hr>
<p>手脱nspack（北斗）1.3 的壳</p>
<p>1、ESP定律，命令：hr ESP地址 【脱壳后程序不能正常运行】 </p>
<p>2、用 ImportREC 这个工具进行修复，修复后程序正常运行。</p>
<p><strong>另类方法脱 ASPack 2.12R 壳的技巧</strong></p>
<p>Ctrl+S 搜索：retn 0C【retn和零C 中间有个空格】 找到后向下看，如下：</p>
<p>retn 0C  push 0 //在 retn 0C 的下面  retn //在这个地方按 F2（下断） ；</p>
<p>F9（运行）</p>
<p>停止后按 一下 F8（单步）；</p>
<p>再按一下 F7（跟进） 观看这看不懂？没关系，要是我，我也看不懂，所以我早有准备；</p>
<p>详细步骤，如下（这是某程序的一部分）：</p>
<p>程序中断后来到这里：   0046B3B8 C2 oc00 retn 0C //开始F8（单步）</p>
<p>  0046B3B9 68 64584500 push registra.00455864 //这里调用来自 00455864 （OEP）  0046B3C0 C3 retn //F7(跟进) 步入到OEP</p>
<p><strong>注意</strong>：<strong>这种壳</strong>ESP<strong>不能直接脱</strong>。</p>
<p>脱FSG v2.0技巧</p>
<p>用od打开之后找到一个三跳转的地方，就是一个判断跳转语句跳过了一个jmp，用F4走到jmp的位置，单步就可以找到oep的位置，用lordpe转存之后在修复的时候还有个坑，fsg会在输入表的地方加一些无用的干扰，所以要手工定位，找到一个API，用d 地址的命令找到输入表开始的地方减去基址为rva，在判断一下大小，最后把无效函数去掉，在修复转存文件就可以了。</p>
<p>手脱PECompact 2.x</p>
<p>这个壳一般先给eax赋值然后压栈，那么一定会访问eax，所以我们运行到push eax下面，然后给eax里的地址下一个访问断点，接着不断地f9，会有一个jmp大跳转，单步跟过去就是oep</p>
<p>手脱KBys Packer</p>
<p>od载入，先走几步F8，发现了PUSHAD，这就可以用ESP了，再ESP下断点，F9一步，走到oep附近，F8，发现一个jmp大跳转，跟过去就是熟悉的入口指令，这就是oep了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-利用异常进行反调试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/05/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95/" class="article-date">
      <time datetime="2021-07-05T06:28:41.000Z" itemprop="datePublished">2021-07-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/05/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95/">利用异常进行反调试</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>例程概念：</p>
<p>例程的作用类似于函数，但含义更为丰富一些。例程是某个系统对外提供的功能接口或服务的集合。比如操作系统的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/API/10154">API</a>、服务等就是例程；Delphi或C++Builder提供的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0/7681008">标准函数</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0/3471322">库函数</a>等也是例程。我们编写一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DLL/158044">DLL</a>的时候，里面的输出函数就是这个DLL的例程。</p>
<p>可以这么简单地来<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%90%86%E8%A7%A3">理解</a>：把一段相对独立的代码写成单独的一个模块就是函数的概念。我们可以在自己的程序中编写很多个函数，从而实现模块化编程。但这些模块或者说函数并不一定向外输出（即提供给别的程序使用），只用于当前这个程序里面。此时这些函数就仅仅具有独立函数的意义，但不是例程。</p>
<p>但如果我们把这些函数编写为DLL动态库的输出函数的话，此时虽然对于编写这个DLL的程序员来讲，仍然可以用函数的概念来理解这些DLL提供的功能，但对于以后调用这个DLL的程序来说，DLL里面提供的输出函数（或者说服务）就是例程了。因此“例程”的基本概念就包含了“例行事务性子程序”的含义，既然是例行的事务子程序，则必然通用性和相对独立性都比较强，所以很适合通过DLL、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%BA%93">静态库</a>（各种编程语言里面的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0">库函数</a>）、API、操作<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1">系统服务</a>等方式来实现了。</p>
<h1 id="2种基于异常机制的反调试方法"><a href="#2种基于异常机制的反调试方法" class="headerlink" title="2种基于异常机制的反调试方法"></a>2种基于异常机制的反调试方法</h1><p>利用异常处理例程来进行反跟踪</p>
<p>SetUnhandledExceptionFilter</p>
<p> 如题，一种是利用异常处理例程进行反调试:首先安装好一个异常处理例程，然后人为抛出异常在异常处理例程中通过IsDebuggerPresent来判断程序是否被调试；另一种是利用未处理异常进行反跟踪，其原理是：当异常发生时所有异常处理例程都不能处理异常，系统线程异常处理例程将起作用,它调用 ZwQueryInformationProcess 判断是否被调试,<br>如果没有调试并且程序中调用SetUnhandledExceptionFilter安装了最后异常处理例程的话,系统转向对它的调用。</p>
<pre><code>第一种方法中IsDebuggerPresent是通过返回FS寄存器上记录的地址的一些偏移量来实现的。在debugger中可以任意操作当前进程内存地址上的值，所以只需要用调试器把［［FS:30］:2的值修改成0，IsDebuggerPresent就会返回false，导致判断失败。相比第二种方法中UnhandledExceptionFilter是否调用取决于系统内核的判断。用户态的调试器要想改变这个行为就得颇费功夫了。下面我将依次展示两种反调试方法。

第一种方法，通过在异常处理例程中判断IsDebuggerPresent的返回值:
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/7574055.html">常见注入手法第二讲,APC注入 - iBinary - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cppblog.com/fwxjj/archive/2008/01/25/41914.html">SEH的强大功能之一(转) - 大龙的博客 - C++博客 (cppblog.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40890756/article/details/89950455">(11条消息) SEH的介绍及实战_For Geek-CSDN博客</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RE/" rel="tag">RE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-释放器分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/03/%E9%87%8A%E6%94%BE%E5%99%A8%E5%88%86%E6%9E%90/" class="article-date">
      <time datetime="2021-07-03T03:20:48.000Z" itemprop="datePublished">2021-07-03</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/03/%E9%87%8A%E6%94%BE%E5%99%A8%E5%88%86%E6%9E%90/">释放器分析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="释放器类样本-分析报告"><a href="#释放器类样本-分析报告" class="headerlink" title="释放器类样本 分析报告"></a>释放器类样本 分析报告</h1><h3 id="822f943bfb27abc5f1acd66bd76ea46b分析过程："><a href="#822f943bfb27abc5f1acd66bd76ea46b分析过程：" class="headerlink" title="822f943bfb27abc5f1acd66bd76ea46b分析过程："></a>822f943bfb27abc5f1acd66bd76ea46b分析过程：</h3><p>vt分析：</p>
<p><img src="https://i.imgur.com/okQTi3r.png"></p>
<p><img src="https://i.imgur.com/eX3dwZ7.png"></p>
<p>释放文件</p>
<p><img src="https://i.imgur.com/txZVVzR.png"></p>
<p>执行释放文件， 大多是注册表操作</p>
<p>释放文件</p>
<p><img src="https://i.imgur.com/AxVorVd.png"></p>
<h5 id="ida分析病毒样本"><a href="#ida分析病毒样本" class="headerlink" title="ida分析病毒样本"></a>ida分析病毒样本</h5><p>start函数直接发现关键位置</p>
<p><img src="https://i.imgur.com/Ky79BJF.png"></p>
<p>三个关键API，CreateFileA先创建⽂件，WriteFile写⼊⽂件，最后ShellExecuteA执⾏⽂件。</p>
<p>静调没发现什么文件信息.</p>
<h5 id="动调过程："><a href="#动调过程：" class="headerlink" title="动调过程："></a>动调过程：</h5><p>单步调，发现MZ，转到内存窗口查看，是pe文件</p>
<p><img src="https://i.imgur.com/Rf4v5CF.png"></p>
<p>接着调可以发现字符串，推测是上述pe的文件名</p>
<p><img src="https://i.imgur.com/9NYIERf.png"></p>
<p>发现释放文件的路径</p>
<p><img src="https://i.imgur.com/U6aB9Vu.png"></p>
<p><img src="https://i.imgur.com/Rs7lOxO.png"></p>
<p>在该目录中发现rename-me.exe，此时数据还没写入，文件大小0kb</p>
<p><img src="https://i.imgur.com/qIYc8Q9.png"></p>
<p>调到writefile函数执行，push eax，跟到内存窗口中，是写入文件的数据，比对两次发现的数据得到释放的文件没有经过任何加密操作。</p>
<p><img src="https://i.imgur.com/wZoBzLE.png"></p>
<p>ShellExecuteA执行rename-me.exe </p>
<p><img src="https://i.imgur.com/H9Vc3no.png"></p>
<p>跳转到40211B  向下跳发现另一个字符串，释放又一个可执行文件1205432525.exe</p>
<p><img src="https://i.imgur.com/5r5aVGB.png"></p>
<p>与rename-me.exe在同一目录下</p>
<p><img src="https://i.imgur.com/lBhHCvt.png"></p>
<p><img src="https://i.imgur.com/hMQIwEp.png"></p>
<p><img src="https://i.imgur.com/DLIXWgB.png"></p>
<p>最终写进可执行文件中的数据，与前面看到的进行对比，发现数据也没有进行加密</p>
<h5 id="提取过程："><a href="#提取过程：" class="headerlink" title="提取过程："></a>提取过程：</h5><p>既然释放的文件直接存储在pe的数据段中，分析pe格式，直接提取文件</p>
<p>参考这个</p>
<p><img src="file:///C:\Users\lenovo\AppData\Roaming\Tencent\QQ\Temp[5UQ[BL(6~BS2JV6W}N6[%S.png" alt="img"><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-125674.htm">https://bbs.pediy.com/thread-125674.htm</a></p>
<p>提取结果：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210703112852985.png" alt="image-20210703112852985"></p>
<p>把提取的文件与代码运行释放的文件和动调过程中在内存窗口观察到的内容进行对比，一致，提取成功。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE/pe资源提取" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/" class="article-date">
      <time datetime="2021-07-01T09:05:13.000Z" itemprop="datePublished">2021-07-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/07/01/PE/pe%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/">pe资源提取</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> 最近分析的病毒样本  ，是释放器类型的，接触到的一类简单的释放器样本，数据不进行加密直接存在pe资源中，想办法把pe文件资源提取出来存在文件中，或者是弄个类似resource hacker 那种，提取资源文件。</p>
<h2 id="pe文件资源提取出来存在文件中"><a href="#pe文件资源提取出来存在文件中" class="headerlink" title="pe文件资源提取出来存在文件中"></a>pe文件资源提取出来存在文件中</h2><p>1.调试器后拷贝文件</p>
<p>释放器释放文件会用到writefile函数  ，可以在用调试器调试过程中，在wirtefile之后，直接拷贝文件，在对后续样本进行分析。</p>
<p>2.利用ida脚本</p>
<p>需要知道写入文件的地址，文件的大小</p>
<p>利用方式：</p>
<p>创建的文件和当前idb文件在同目录下，用IDA打开一个idb文件，file–&gt;script file –&gt;xxx.idc</p>
<p>自行填写填入资源的文件名   数据地址   大小（file ，addstart，size）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> file =<span class="string">&quot;xxx.bin&quot;</span>;<span class="comment">//写入pe文件资源的文件</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> addstart=<span class="number">0</span>x。。。。。;<span class="comment">//数据的地址</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> size=<span class="number">0</span>x。。。;<span class="comment">//大小</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">auto</span> hfile=openfile(file);</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        writefile(hfile,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">openfile</span><span class="params">(file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> hfile=fopen(file,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(hfile==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Message(<span class="string">&quot;create file failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> hfile ;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> hfile;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">writefile</span><span class="params">(hfile,addstart,size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret=savefile(hfile,<span class="number">0</span>,addstart,size);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                Mesage(<span class="string">&quot;write file error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Message(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类似resource-hacker-的资源提取工具"><a href="#类似resource-hacker-的资源提取工具" class="headerlink" title="类似resource hacker 的资源提取工具"></a>类似resource hacker 的资源提取工具</h2><h3 id="pe资源相关知识"><a href="#pe资源相关知识" class="headerlink" title="pe资源相关知识"></a>pe资源相关知识</h3><h3 id="资源提取器代码实现"><a href="#资源提取器代码实现" class="headerlink" title="资源提取器代码实现"></a>资源提取器代码实现</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE/" rel="tag">PE</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 Pyikaaaa
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/Pyikaaaa" target="_blank">Blog</a> ❤ Pyikaaaa
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>